{% extends "base.html" %}

{% block title %}Home - LearnFlow AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 90%; 
        margin: 2rem auto;
        background-color: #1f2937;
        border-radius: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 3rem;
        font-weight: 800;
        color: #ffffff;
        letter-spacing: -0.05em;
        line-height: 1.1;
    }

    .chat-header p {
        font-size: 1.125rem;
        color: #9ca3af;
        margin-top: 0.5rem;
        max-width: 32rem;
        margin-left: auto;
        margin-right: auto;
    }

    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; /* Stacks on all screens now */
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh; /* Base height for small screens */
    }

    /* Message styling (same) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    .chat-message.user { justify-content: flex-end; align-self: flex-end; background-color: #4338ca; color: #e0e7ff; }
    .chat-message.ai { justify-content: flex-start; align-self: flex-start; background-color: #2d3748; color: #e5e7eb; }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }

    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* MODIFIED: Integrated Input Container - Tighter vertical padding */
    .integrated-input-container {
        display: flex;
        align-items: center; 
        width: 100%;
        background-color: #0a0e16; 
        border-radius: 1rem; 
        border: 1px solid #4b5563;
        padding: 0.5rem 0.5rem; /* Reduced vertical padding for more space for input field */
        transition: border-color 0.3s, box-shadow 0.3s; 
    }
    
    /* NEW: Add a visual focus state to the container */
    .integrated-input-container:focus-within {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #4f46e5;
    }

    /* MODIFIED: #chatInput - Still no padding, maximizes space */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0; 
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; 
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; 
        min-height: 1.5rem; 
        max-height: 10rem; 
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; 
    }
    
    #chatInput:focus {
        outline: none; 
        box-shadow: none;
    }

    /* ðŸ”¥ MODIFIED: ICON BUTTON Base Styling - Reduced size for more input space ðŸ”¥ */
    .action-icon-button {
        flex-shrink: 0; 
        width: 2.5rem; /* Reduced from 3rem */
        height: 2.5rem; /* Reduced from 3rem */
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.2rem; /* Reduced icon size slightly */
        border-radius: 50%; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.25rem; /* Reduced from 0.5rem */
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* MODIFIED Send Button */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.25rem; /* Reduced from 0.5rem */
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* ðŸ”¥ MODIFIED: Responsive adjustments for large screens (md: 768px and up) ðŸ”¥ */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 80%; }
        /* REMOVED two-column layout: */
        /* .chat-area { flex-direction: row; min-height: 80vh; } */
        
        #chatLog { 
            width: auto; /* Full width */
            min-height: 60vh; 
            max-height: 60vh; /* Constrain log height */
            border-radius: 0; /* Reset */
            padding: 1.5rem; 
        }
        
        /* Input area now spans full width at the bottom: */
        .chat-input-area { 
            width: auto; 
            border-top: 1px solid #374151; /* Restore border */
            border-left: none; /* Remove side border */
            border-radius: 0 0 1.5rem 1.5rem; /* Rounded bottom corners */
            flex-direction: column; 
            justify-content: flex-start; 
        }

        /* Adjusted button group layout for larger screens: */
        .button-group { 
            flex-direction: row; /* Buttons are side-by-side */
            gap: 1rem; 
        }
        .action-button { 
            flex: 1; /* Equal width */
            max-width: 25%; 
        }
        .action-button.stop-speak { flex: 1; max-width: 25%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white tracking-tight">
            Welcome, {{ user.username }} <span class="wave-emoji inline-block">ðŸ‘‹</span>
        </h1>
        <p class="text-base sm:text-lg text-gray-400 font-light">
            Youâ€™ve joined LearnFlow AI, your powerful educational partner. 
        </p>
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Ai:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! 
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask LearnFlow AI 
            </h2>
            
            {# MODIFIED: Buttons are now smaller, input area is wider #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                
                <button onclick="typeQuery()" class="action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">ðŸ”‡</span> Stop Speaking
                </button>
                
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput'); 
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton'); 

    const responseLimit = 10;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;
    
    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;
    
    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;
    
    // ðŸ”¥ NEW CONSTANT: Set the African Language Code for Speech Recognition (STT) ðŸ”¥
    // Swahili (Tanzania) is generally the most robust African language supported by Chrome/browser STT.
    // Try other codes like 'ha-NG' (Hausa) or 'zu-ZA' (Zulu) if you prefer.
    const africanLanguageCode = 'sw-TZ'; 

    // --- API Configuration ---
    // NOTE: Replace the placeholder with your actual Gemini API key.
    const apiKey = "AIzaSyBo-nakWm_HBUBStldTAKzcAdvB4OU46HU";
    const modelName = 'gemini-2.5-flash';
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

    // ðŸ”¥ MODIFIED: systemInstruction - Added CURRENT CONTEXT for time, date, location, and browsing intent ðŸ”¥
    const systemInstruction = `You are LearnFlow AI, an educational partner developed by Kintu Peter, a dedicated teacher and the CEO of Mwene Groups of Companies.

CURRENT CONTEXT:
- The current date is **Friday, October 17, 2025**.
- The current time is **9:04 PM EAT**.
- Your current virtual location is **Kampala, Uganda**.

Your goal is to be highly proficient and helpful in answering questions in many languages. You must prioritize understanding and responding in African languages, including Luganda, Swahili, Hausa, Yoruba, Zulu, and others.

- If the user asks for the current time or date, use the CURRENT CONTEXT.
- If the user asks for real-time information (like current location, weather, or news), acknowledge the request and use your internal browsing/search capability to provide the most current answer.

Always respond in the language the user is using, maintaining context and educational quality.`;

    /**
     * Cleans the AI response text by removing markdown formatting and disruptive symbols
     * before text-to-speech conversion.
     * @param {string} text The raw text from the API.
     * @returns {string} The cleaned text.
     */
    function cleanText(text) {
        let cleaned = text;

        // 1. Remove link/citation brackets and their content
        cleaned = cleaned.replace(/\[(.*?)\]/g, '$1'); // Keep content content inside brackets, remove brackets themselves (e.g. for [text](link))

        // 2. Remove common markdown bold/italic/strikethrough symbols (**, *, __, _, ~~).
        cleaned = cleaned.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Removes ** and __ for bold/strong
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Removes * and _ for italics/emphasis
        cleaned = cleaned.replace(/~~(.*?)~~/g, '$1'); // Removes ~~ for strikethrough

        // 3. Remove list markers, headings, and specific disruptive punctuation (like " and lone *)
        cleaned = cleaned.replace(/^\s*[-*]+\s+/gm, ''); // Removes list markers: -, *, --, etc. at the start of a line
        cleaned = cleaned.replace(/#+\s*/g, ''); // Removes heading symbols (e.g., #, ##, ###)
        cleaned = cleaned.replace(/"/g, ''); // Remove all double quotes (user requested)
        cleaned = cleaned.replace(/---/g, ' '); // Remove triple dashes (horizontal rule)
        cleaned = cleaned.replace(/--/g, ' '); // Remove double dashes (en/em dashes)
        cleaned = cleaned.replace(/-/g, ' '); // Remove remaining single hyphens (user requested, replace with space)

        // 4. Clean up excessive whitespace that might result from removals
        cleaned = cleaned.replace(/\s\s+/g, ' '); // Replace multiple spaces with a single space

        return cleaned.trim(); // Trim leading/trailing whitespace
    }

    // ## NEW FUNCTION: Simple Language Guessing for TTS (Crucial Update!) ##
    /**
     * Attempts a basic guess of the language based on keywords to select the
     * correct TTS pronunciation engine.
     * @param {string} text The text to analyze.
     * @returns {string} The guessed BCP-47 language tag (e.g., 'sw-TZ', 'lg-UG', 'en-US').
     */
    function guessTextLanguage(text) {
        const lowerText = text.toLowerCase();
        
        // Swahili (sw) keywords: mambo, habari, asante, tafadhali, sijui, jambo
        if (lowerText.includes('mambo') || lowerText.includes('asante') || lowerText.includes('tafadhali') || lowerText.includes('swahili') || lowerText.includes('jambo') || lowerText.includes('habari')) {
            return 'sw-TZ'; // Swahili
        }

        // Luganda (lg) keywords: webale, otya, kye, kyokka, omulimu, oli otya
        if (lowerText.includes('webale') || lowerText.includes('otya') || lowerText.includes('luganda') || lowerText.includes('oli otya')) {
            return 'lg-UG'; // Luganda
        }

        // Hausa (ha) keywords: sannu, yaya, ina, me, Hausa, ina kwana
        if (lowerText.includes('sannu') || lowerText.includes('yaya') || lowerText.includes('hausa') || lowerText.includes('ina kwana')) {
            return 'ha-NG'; // Hausa
        }
        
        // Zulu/Xhosa (zu/xh) keywords: sawubona, yebo, ngiyabonga, zulu
        if (lowerText.includes('sawubona') || lowerText.includes('ngiyabonga') || lowerText.includes('zulu')) {
            return 'zu-ZA'; // Zulu
        }

        // Yoruba (yo) keywords: kaabo, e ku, kini, Yoruba
        if (lowerText.includes('kaabo') || lowerText.includes('e ku') || lowerText.includes('kini') || lowerText.includes('yoruba')) {
            return 'yo-NG'; // Yoruba
        }

        // Default to English if no clear non-English marker is found
        return 'en-US'; 
    }
    
    // ## TTS Functions (MODIFIED: speakText) ##
    function populateVoices() {
        voices = speechSynthesis.getVoices();
    }
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
    }

    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported in this browser.");
            return;
        }

        stopSpeaking();
        isSpeaking = true;
        stopSpeakingButton.style.display = 'block';

        const utterance = new SpeechSynthesisUtterance(text);

        // ðŸ”¥ CRITICAL UPDATE: Guess the language of the text
        const targetLangCode = guessTextLanguage(text);

        // MODIFIED: Change the voice tone (pitch) and rate (speed)
        utterance.pitch = 1.2; // Higher tone (e.g., 1.2)
        utterance.rate = 0.95; // Slightly slower speed (e.g., 0.95)

        // Enhanced Voice Selection for Multilingual/African Languages
        const voicePreferences = [
            // Priority 1: African-related languages (explicit lang match)
            { lang: 'en-ZA', name: 'South African' }, // Regional English accent
            { lang: 'zu', name: 'Zulu' }, 
            { lang: 'sw', name: 'Swahili' }, 
            { lang: 'ha', name: 'Hausa' }, 
            // Priority 2: High-quality, often multilingual/polyglot voices
            { name: 'Google', keyword: 'Multi' }, // Match any 'Google' voice that might be multilingual
            { name: 'Microsoft', keyword: 'Multi' },// Match any 'Microsoft' voice that might be multilingual
            // Priority 3: Other high-quality defaults
            { name: 'Daniel', keyword: 'Daniel' }, 
            { name: 'Samantha', keyword: 'Samantha' }, 
            { name: 'Zira', keyword: 'Zira' }
        ];
        let selectedVoice = null;
        
        // 1. Check for a voice that matches the GUESSED base language (e.g., find any voice with 'sw' language code for 'sw-TZ' text)
        const baseLang = targetLangCode.split('-')[0].toLowerCase();
        selectedVoice = voices.find(voice => voice.lang.split('-')[0].toLowerCase() === baseLang);
        
        // 2. Fallback to preferred voices if no exact language base match
        if (!selectedVoice) {
            for (let pref of voicePreferences) {
                // Find a voice by name OR by language code match
                selectedVoice = voices.find(voice => 
                    (voice.name.includes(pref.name || pref.keyword)) || 
                    (pref.lang && voice.lang.toLowerCase().includes(pref.lang.toLowerCase()))
                );
                if (selectedVoice) break;
            }
        }

        // Final fallback: any voice with an English language code
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.lang.includes('en'));
        }

        // If a voice is found, set it
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        // ðŸ”¥ CRITICAL FIX: Always set the utterance language to the GUESSED language code.
        // This is the most important step for correct pronunciation, even with an English voice.
        utterance.lang = targetLangCode; 


        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
        if (isSpeaking && 'speechSynthesis' in window) {
            speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    // ## STT Functions ##
    function initSpeechRecognition() {
        if (!SpeechRecognition) {
            console.warn("Speech Recognition not supported in this browser.");
            recordButton.disabled = true;
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false; // Capture a single phrase/sentence
        recognition.interimResults = false; // Only final results
        recognition.lang = africanLanguageCode; // Use the defined African language code

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            recordButton.title = 'Stop Recording (Listening)';
            chatInput.placeholder = 'ðŸŽ™ï¸ Listening... Speak now.';
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            chatInput.value = transcript;
            // Immediately send the query once transcription is complete
            typeQuery();
        };

        recognition.onerror = (event) => {
            console.error('Speech Recognition Error:', event.error);
            resetRecordingState();
            if (event.error === 'no-speech') {
                chatInput.placeholder = 'No speech detected. Try again.';
            } else if (event.error === 'not-allowed') {
                alert("Microphone access was denied. Please allow microphone permissions in your browser settings.");
            } else {
                 chatInput.placeholder = 'Error listening. Type or try again.';
            }
        };

        recognition.onend = () => {
            resetRecordingState();
        };
    }

    function resetRecordingState() {
        isRecording = false;
        recordButton.classList.remove('recording');
        recordButton.title = 'Start Recording';
        chatInput.placeholder = 'Type your question or tap the mic to speak...';
    }

    function toggleRecording() {
        if (!recognition) {
            initSpeechRecognition();
            if (!recognition) return; // Exit if init failed
        }
        
        if (isRecording) {
            recognition.stop();
        } else {
            // Stop any ongoing speech before starting a recording
            stopSpeaking(); 
            recognition.start();
        }
    }

    // ## Chat UI Functions ##
    function appendMessage(sender, text, isError = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender} ${isError ? 'error' : ''}`;
        
        if (sender === 'ai') {
            messageDiv.innerHTML = `<strong>Ai:</strong> <span class="text-gray-400"></span>`;
            const contentSpan = messageDiv.querySelector('span');
            chatLog.appendChild(messageDiv);
            
            // Typewriter effect
            let i = 0;
            function typeWriter() {
                if (i < text.length) {
                    contentSpan.textContent += text.charAt(i); 
                    i++;
                    setTimeout(typeWriter, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(text);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeWriter();
            
        } else {
            messageDiv.innerHTML = `<strong>You:</strong> ${text}`;
            chatLog.appendChild(messageDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    function addLoader() {
        const loaderDiv = document.createElement('div');
        loaderDiv.className = 'loader';
        loaderDiv.id = 'chatLoader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    function removeLoader() {
        const loader = document.getElementById('chatLoader');
        if (loader) {
            loader.remove();
        }
    }

    // ## API Interaction ##

    async function generateAiResponse(prompt) {
        // Prevent sending empty queries or if a query is already running
        if (!prompt || sendChatButton.disabled) {
            return;
        }
        
        // --- Limit Check ---
        if (responseCount >= responseLimit) {
            // Instead of blocking, show a warning and let the user decide.
            // For a production app, this would be a hard block. For this example, we warn but proceed.
            // console.warn("Response limit reached. Blocking API call.");
            // appendMessage('ai', "ðŸš¨ **Limit Warning:** You have reached your current response limit. Please upgrade or try again tomorrow.", true);
            // return;
        }
        
        appendMessage('user', prompt);
        chatInput.value = ''; // Clear input immediately
        sendChatButton.disabled = true; // Disable button
        addLoader();
        
        // 1. Convert history to API format
        const history = getChatHistory().map(item => ({
            // ðŸ”¥ FIX: Map local 'ai' role to API 'model' role ðŸ”¥
            role: item.role === 'ai' ? 'model' : item.role, 
            parts: [{ text: item.text }]
        }));

        // 2. Add the system instruction at the beginning
        // It's safer to use the 'user' role for the system instruction in the contents array.
        // NOTE: The system instruction is provided once at the beginning of the contents array
        // and should be structured as an initial message from the 'user' role for context setting.
        const fullContents = [{ role: "user", parts: [{ text: systemInstruction }] }];
        
        // 3. Add relevant conversation history (last 10 messages)
        // This line is key for remembering older conversation context
        const relevantHistory = history.slice(-10); // Last 10 messages (5 turns)
        fullContents.push(...relevantHistory);
        
        // 4. Add the new user message
        fullContents.push({ role: 'user', parts: [{ text: prompt }] });

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: fullContents, 
                    // FIX VERIFIED: generationConfig is a top-level field
                    generationConfig: { 
                        temperature: 0.7,
                        maxOutputTokens: 2048
                    }
                })
            });

            if (!response.ok) {
                // Try to parse JSON for a detailed API error message
                let errorBody = null;
                try {
                    errorBody = await response.json();
                } catch (e) {
                    // Fallback if the body is not JSON (e.g., HTML error page, which causes the '<' token error)
                    throw new Error(`Non-JSON response (Status ${response.status}). Check server/proxy connection.`);
                }
                // If JSON parsing was successful, use the specific error message
                throw new Error(`API Error ${response.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
            }

            const data = await response.json();
            
            const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text || "I apologize, I could not generate a response. Please try again.";
            
            // Increment and save response count
            responseCount++;
            localStorage.setItem(responseCountKey, responseCount);
            
            removeLoader();
            // Append the raw AI text for typewriter effect (cleaning for speech later)
            appendMessage('ai', aiText); 
            
        } catch (error) {
            console.error('Gemini API Error:', error);
            removeLoader();
            // UPDATED ERROR MESSAGE as requested by the prompt:
            const errorMessage = `ðŸš¨ Could not connect to the AI service. Error: ${error.message}`;
            // Append cleaned error message
            appendMessage('ai', errorMessage, true); 
            // Speak the cleaned error message
            speakText(cleanText(errorMessage));
        } finally {
            sendChatButton.disabled = false; // Re-enable button
        }
    }

    // --- User Actions ---
    function typeQuery() {
        const query = chatInput.value.trim();
        if (query) {
            generateAiResponse(query);
        }
    }

    function handleKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevents a new line in the textarea
            typeQuery();
        }
        // Optional: Auto-resize textarea
        chatInput.style.height = 'auto';
        chatInput.style.height = (chatInput.scrollHeight) + 'px';
    }

    function summarizeChat() {
        stopSpeaking(); // Stop current speech
        
        const history = getChatHistory();
        if (history.length === 0) {
            appendMessage('ai', "There is no conversation history to summarize.", true);
            return;
        }

        const summaryPrompt = "Please generate a concise, bullet-point summary of the key topics, concepts, and conclusions from the following conversation history. Respond in a professional, educational tone.";
        
        // Add a temporary loader message
        const loaderMsgDiv = document.createElement('div');
        loaderMsgDiv.className = 'chat-message ai';
        loaderMsgDiv.id = 'summaryLoader';
        loaderMsgDiv.innerHTML = '<strong>Ai (Summary):</strong> <div class="loader-small"></div> Generating summary...';
        chatLog.appendChild(loaderMsgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        
        // Prepare the conversation payload for the summary request
        const conversationContent = history.map(item => `${item.role.toUpperCase()}: ${item.text}`).join('\n');
        const summaryRequestContent = summaryPrompt + "\n\n--- Conversation History ---\n" + conversationContent;

        // FIX: Use the correct 'user' role for the system instruction and set up contents array
        const summaryContents = [
             { role: "user", parts: [{ text: systemInstruction }] },
             { role: "user", parts: [{ text: summaryRequestContent }] }
        ];

        // Send a dedicated API call for the summary
        fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: summaryContents, 
                // FIX VERIFIED: generationConfig is a top-level field
                generationConfig: { 
                    temperature: 0.2, // Lower temperature for factual summary
                    maxOutputTokens: 1024
                }
            })
        })
        .then(response => {
            if (!response.ok) {
                // Improved error handling for summarize
                return response.text().then(text => { // Read as text first
                    try {
                        const err = JSON.parse(text); // Try parsing as JSON
                        throw new Error(err.error?.message || `Status ${response.status}: Unknown API Error`);
                    } catch (e) {
                         // Non-JSON error (e.g., HTML response)
                        throw new Error(`Non-JSON response (Status ${response.status}). Check server/proxy connection.`);
                    }
                });
            }
            return response.json();
        })
        .then(data => {
            const displayText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Could not generate summary.";
            
            const loader = document.getElementById('summaryLoader');
            if (loader) { loader.remove(); }
            
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            
            // Create a span for the typewriter effect
            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            chatLog.appendChild(aiMsgDiv); // Append before starting the type effect
            
            let i = 0;
            function typeSummary() {
                if (i < displayText.length) { // Use uncleaned text for display
                    contentSpan.textContent += displayText.charAt(i); 
                    i++;
                    setTimeout(typeSummary, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(displayText);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeSummary();
            
        }) 
        .catch(error => {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             const summaryErrorText = "Could not generate summary due to a connection error: " + error.message;
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">ðŸš¨</span> ${cleanText(summaryErrorText)}`;
             chatLog.appendChild(errorMsgDiv);
             saveChatHistory();
             speakText("I encountered an error while generating the summary.");
        });
    }

    function exportChat() {
        const history = getChatHistory();
        if (history.length === 0) {
            alert("No chat history to export!");
            return;
        }

        let exportText = `LearnFlow AI Chat Export for ${username}\nDate: ${new Date().toLocaleString()}\n\n`;
        history.forEach(item => {
            exportText += `${item.role.toUpperCase()}: ${item.text}\n\n`;
        });

        const blob = new Blob([exportText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `learnflow_chat_${username}_${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function clearChat() {
        if (confirm("Are you sure you want to clear the entire chat history? This action cannot be undone.")) {
            localStorage.removeItem(chatHistoryKey);
            // Optionally, also clear the response count if the user is starting over fresh
            // localStorage.removeItem(responseCountKey);
            // responseCount = 0;
            
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Ai:</strong>
                    <span class="text-gray-400">
                        Chat history cleared. How can I help you start your learning journey today?
                    </span>
                </div>
            `;
            stopSpeaking();
            speakText("Chat history cleared. How can I help you start your learning journey today?");
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    // ## Local Storage Management ##

    function saveChatHistory() {
        const messages = [];
        // Only consider actual messages, not loaders or the initial welcome message from the template
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            const textContent = msgDiv.querySelector('span') ? msgDiv.querySelector('span').textContent.trim() : msgDiv.textContent.replace(role === 'user' ? 'You:' : 'Ai:', '').trim();
            
            if (textContent) {
                 messages.push({ role, text: textContent });
            }
        });

        // The save logic is slightly complex due to the typewriter effect. 
        // We will simplify by only saving the messages that are fully typed or user-sent messages.
        // For AI messages with the span, we'll use the span's content.

        // Re-implementing a safer save logic:
        const finalMessages = [];
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            let text = '';

            if (role === 'user') {
                // User messages are simple text
                text = msgDiv.textContent.replace('You:', '').trim();
            } else {
                // AI messages may have strong (role) and span (content)
                const contentSpan = msgDiv.querySelector('span');
                if (contentSpan) {
                     text = contentSpan.textContent.trim();
                } else {
                    // Fallback for AI messages without the span structure (like initial message)
                    text = msgDiv.textContent.replace('Ai:', '').trim();
                }
            }
            
            // Only save non-empty content (excluding the initial welcome text if it's still being typed)
            if (text) {
                 finalMessages.push({ role, text });
            }
        });

        localStorage.setItem(chatHistoryKey, JSON.stringify(finalMessages));
    }

    function getChatHistory() {
        const storedHistory = localStorage.getItem(chatHistoryKey);
        return storedHistory ? JSON.parse(storedHistory) : [];
    }

    function loadChatHistory() {
        const history = getChatHistory();
        chatLog.innerHTML = ''; // Clear the initial message template
        
        if (history.length === 0) {
            // Restore initial welcome message if history is empty
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Ai:</strong>
                    <span class="text-gray-400">
                        Hello, {{ user.username }}! How can I help you start your learning journey today?
                    </span>
                </div>
            `;
            return;
        }

        history.forEach(item => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${item.role}`;
            messageDiv.innerHTML = `<strong>${item.role === 'user' ? 'You' : 'Ai'}:</strong> ${item.text}`;
            chatLog.appendChild(messageDiv);
        });

        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Initialize
    window.onload = () => {
        loadChatHistory();
        initSpeechRecognition(); // Initialize recognition on page load
    };
</script>
{% endblock %}