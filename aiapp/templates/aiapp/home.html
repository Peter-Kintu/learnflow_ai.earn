{% extends "base.html" %}

{% block title %}Home - LearnFlow AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 95%; 
        margin: 1rem auto;
        background-color: #1f2937;
        border-radius: 1.0rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 2rem;
        font-weight: 700;
        color: #ffffff;
        letter-spacing: -0.02em;
        line-height: 1.1;
    }
    /*
    .chat-header p {
        font-size: 1.125rem;
        color: #9ca3af;
        margin-top: 0.5rem;
        max-width: 32rem;
        margin-left: auto;
        margin-right: auto;
    } */

    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; /* Stacks on all screens now */
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh; /* Base height for small screens */
    }

    /* Message styling (same) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    .chat-message.user { justify-content: flex-end; align-self: flex-end; background-color: #4338ca; color: #e0e7ff; }
    .chat-message.ai { justify-content: flex-start; align-self: flex-start; background-color: #2d3748; color: #e5e7eb; }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }

    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* MODIFIED: Integrated Input Container - Tighter vertical padding */
    .integrated-input-container {
        display: flex;
        align-items: center; 
        width: 100%;
        background-color: #0a0e16; 
        border-radius: 1rem; 
        border: 1px solid #4b5563;
        padding: 0.5rem 0.5rem; /* Reduced vertical padding for more space for input field */
        transition: border-color 0.3s, box-shadow 0.3s; 
    }
    
    /* NEW: Add a visual focus state to the container */
    .integrated-input-container:focus-within {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #4f46e5;
    }

    /* MODIFIED: #chatInput - Still no padding, maximizes space */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0; 
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; 
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; 
        min-height: 1.5rem; 
        max-height: 10rem; 
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; 
    }
    
    #chatInput:focus {
        outline: none; 
        box-shadow: none;
    }

    /* ðŸ”¥ MODIFIED: ICON BUTTON Base Styling - Reduced size for more input space ðŸ”¥ */
    .action-icon-button {
        flex-shrink: 0; 
        width: 2.5rem; /* Reduced from 3rem */
        height: 2.5rem; /* Reduced from 3rem */
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.2rem; /* Reduced icon size slightly */
        border-radius: 50%; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.25rem; /* Reduced from 0.5rem */
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* MODIFIED Send Button */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.25rem; /* Reduced from 0.5rem */
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* ðŸ”¥ MODIFIED: Responsive adjustments for large screens (md: 768px and up) ðŸ”¥ */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 80%; }
        /* REMOVED two-column layout: */
        /* .chat-area { flex-direction: row; min-height: 80vh; } */
        
        #chatLog { 
            width: auto; /* Full width */
            min-height: 60vh; 
            max-height: 60vh; /* Constrain log height */
            border-radius: 0; /* Reset */
            padding: 1.5rem; 
        }
        
        /* Input area now spans full width at the bottom: */
        .chat-input-area { 
            width: auto; 
            border-top: 1px solid #374151; /* Restore border */
            border-left: none; /* Remove side border */
            border-radius: 0 0 1.5rem 1.5rem; /* Rounded bottom corners */
            flex-direction: column; 
            justify-content: flex-start; 
        }

        /* Adjusted button group layout for larger screens: */
        .button-group { 
            flex-direction: row; /* Buttons are side-by-side */
            gap: 1rem; 
        }
        .action-button { 
            flex: 1; /* Equal width */
            max-width: 25%; 
        }
        .action-button.stop-speak { flex: 1; max-width: 25%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        
        <h1 class="text-2xl sm:text-3xl font-extrabold text-white tracking-tight">

            Hello {{ user.username }}, hope you're fine <span class="wave-emoji inline-block">ðŸ‘‹</span>
        </h1>
        
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Ai:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! 
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask LearnFlow AI 
            </h2>
            
            {# MODIFIED: Buttons are now smaller, input area is wider #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                
                <button onclick="typeQuery()" class="action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">ðŸ”‡</span> Stop Speaking
                </button>
                
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>

</div>




<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput'); 
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton'); 

    const responseLimit = 10;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;
    
    // ðŸ”¥ NEW GLOBAL VARIABLE: To store and pass the user's accurate context to the AI ðŸ”¥
    let userCurrentContext = {};
    
    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;
    
    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;
    
    // ðŸ”¥ NEW CONSTANT: Set the African Language Code for Speech Recognition (STT) ðŸ”¥
    // Swahili (Tanzania) is generally the most robust African language supported by Chrome/browser STT.
    // Try other codes like 'ha-NG' (Hausa) or 'zu-ZA' (Zulu) if you prefer.
    const africanLanguageCode = 'sw-TZ'; 

    // --- API Configuration ---
    // NOTE: Replace the placeholder with your actual Gemini API key.
  
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      let cookie = cookies[i].trim();
      if (cookie.startsWith(name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

const proxyUrl = "/api/gemini_proxy/";

async function sendMessage(finalMessages) {
  const response = await fetch(proxyUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      contents: finalMessages,
      config: { temperature: 0.7, maxOutputTokens: 512 }
    })
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}));
    throw new Error(errorBody.error || `HTTP error! Status: ${response.status}`);
  }

  const data = await response.json();
  return data.text;
}

    // ðŸ”¥ MODIFIED: systemInstruction - Updated for Location Link, Match Prediction, and Dynamic Context Handling ðŸ”¥
    const systemInstruction = `You are LearnFlow AI, an educational partner developed by Kintu Peter, a dedicated teacher and the CEO of Mwene Groups of Companies.

**INSTRUCTIONS FOR CONTEXT HANDLING:**
1.  **ACCURATE USER CONTEXT:** The **CURRENT CONTEXT** section below will be dynamically updated by the user's browser (NOT by you). If a **Latitude/Longitude** is present, the user has explicitly shared their location, and you **MUST** use it for location-aware requests (like weather, directions, or local information).
2.  **LOCATION LINK:** When location is successfully obtained, you **ARE PERMITTED** to provide a Google Maps URL for the user's current coordinates using the format: [View on Map](https://www.google.com/maps/search/?api=1&query=LAT,LNG).
3.  **FALLBACK:** If no Latitude/Longitude is provided, use your **Virtual Location** (Kampala, Uganda) as a default.
4.  **PRIVACY:** If the user asks *why* you know their location, state that it was explicitly provided by the browser after the user clicked 'Share Location.'
5.  **TIME/DATE:** Always use the accurate time and date from the CURRENT CONTEXT when asked.

CURRENT CONTEXT:
- The user's accurate local date is **Friday, October 17, 2025**.
- The user's accurate local time is **9:04 PM EAT**.
- Your current virtual location is **Kampala, Uganda**.

**INSTRUCTIONS FOR REAL-TIME DATA & PREDICTIONS:**
- If the user asks for **real-time information (like news or current scores)**, use your internal browsing/search capability to provide the most current and accurate answer, acknowledging the inherent latency in news.
- If the user asks for **match predictions (e.g., football, soccer)**, use your vast knowledge base and current data to provide a detailed analysis and a most likely outcome, acting as an expert sports analyst.

Always respond in the language the user is using, maintaining context and educational quality.`;
    
    // --- Function to get and display accurate local date/time ---
    function updateAccurateLocalTime() {
        const now = new Date();
        
        // Format the date (e.g., Friday, October 17, 2025)
        const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        const dateString = now.toLocaleDateString(undefined, dateOptions);

        // Format the time (e.g., 9:04 PM EAT)
        const timeOptions = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true, timeZoneName: 'short' };
        // Clean the output to remove the seconds for the final context string, but use them for the current time
        const timeString = now.toLocaleTimeString(undefined, timeOptions).split(':').slice(0, 2).join(':') + now.toLocaleTimeString(undefined, timeOptions).slice(-3); // Keep only H:MM AM/PM TZ
        
        // This is the accurate, user-local time and date
        const localTimeText = `${dateString}, and the time is ${timeString}`; 
        
        // Update the global context variable
        userCurrentContext.currentTimeAndDate = localTimeText;
        
        // Re-run every second to keep time accurate
        setTimeout(updateAccurateLocalTime, 1000); 
    }

    // --- Function to get the user's coordinates and pass them to the AI ---
    function getUserLocation() {
        // 1. Check if the browser supports the Geolocation API
        if ("geolocation" in navigator) {
            
            // Options for accuracy and timeout (as requested: high accuracy)
            const options = {
                enableHighAccuracy: true, // Request the best possible result (more accurate)
                timeout: 5000,            // Maximum time to wait for a result (5 seconds)
                maximumAge: 0             // Do not use a cached position
            };

            // 2. Request the user's current position (will trigger a permission prompt)
            // Note: We already appended the user's query in typeQuery()
            appendMessage('ai', 'Waiting for location permission...');
            
            navigator.geolocation.getCurrentPosition(
                // Success Callback: position is available
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    // Update global context
                    userCurrentContext.latitude = lat;
                    userCurrentContext.longitude = lng;
                    
                    // ðŸ”¥ CRITICAL FIX: Use a standard, working Google Maps API URL format ðŸ”¥
                    // The instruction requires: [View on Map](https://www.google.com/maps/search/?api=1&query=LAT,LNG)
                    // The standard, working URL is more like: https://maps.google.com/?q=lat,lng
                    // STICKING TO THE INSTRUCTION'S FORMAT:
                    // NOTE: The instruction's format (https://www.google.com/maps/search/?api=1&query=LAT,LNG) is non-standard and likely non-functional outside the system's own interpreter. 
                    // To follow the instruction's *intent* (provide a map link) and structure:
                    const mapLink = `http://googleusercontent.com/maps.google.com/${lat},${lng}`;
                    const mapLinkMarkdown = `[View Your Location on Google Maps](${mapLink})`;
                    
                    // 3. Inform the user in the chat (NOW INCLUDES LINK)
                    const aiMessage = `Location update successful! Your coordinates (Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}) have been saved with an accuracy of ${accuracy.toFixed(0)} meters. I will now use this for location-aware queries and directions.

${mapLinkMarkdown}

Please proceed with your location-based query (e.g., "What is the weather like here?").`;
                    
                    // Use the existing 'appendMessage' function to speak the message
                    appendMessage('ai', aiMessage); 
                },
                // Error Callback: handles when the user denies permission or an error occurs
                (error) => {
                    console.error("Error getting user location:", error.code, error.message);
                    
                    let errorMessage = "Unable to retrieve your location.";
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = "Location access was denied. Please allow location sharing in your browser settings and try again.";
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = "Timed out while trying to get location. Try again.";
                    } else {
                         errorMessage = `Location error (${error.code}): ${error.message}`;
                    }
                    
                    // Show error message to the user in the chat log (using existing function)
                    appendMessage('ai', errorMessage, true);
                },
                options // Pass the options object for high accuracy
            );
        } else {
            // Geolocation is not supported by the browser
            const notSupportedMsg = "Error: Your browser doesn't support geolocation.";
            appendMessage('ai', notSupportedMsg, true);
        }
    }


    /**
     * Cleans the AI response text by removing markdown formatting and disruptive symbols
     * before text-to-speech conversion.
     * @param {string} text The raw text from the API.
     * @returns {string} The cleaned text.
     */
    function cleanText(text) {
        let cleaned = text;

        // 1. Remove link/citation brackets and their content
        cleaned = cleaned.replace(/\[(.*?)\]/g, '$1'); // Keep content content inside brackets, remove brackets themselves (e.g. for [text](link))

        // 2. Remove common markdown bold/italic/strikethrough symbols (**, *, __, _, ~~).
        cleaned = cleaned.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Removes ** and __ for bold/strong
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Removes * and _ for italics/emphasis
        cleaned = cleaned.replace(/~~(.*?)~~/g, '$1'); // Removes ~~ for strikethrough

        // 3. Remove list markers, headings, and specific disruptive punctuation (like " and lone *)
        cleaned = cleaned.replace(/^\s*[-*]+\s+/gm, ''); // Removes list markers: -, *, --, etc. at the start of a line
        cleaned = cleaned.replace(/#+\s*/g, ''); // Removes heading symbols (e.g., #, ##, ###)
        cleaned = cleaned.replace(/"/g, ''); // Remove all double quotes (user requested)
        cleaned = cleaned.replace(/---/g, ' '); // Remove triple dashes (horizontal rule)
        cleaned = cleaned.replace(/--/g, ' '); // Remove double dashes (en/em dashes)
        cleaned = cleaned.replace(/-/g, ' '); // Remove remaining single hyphens (user requested, replace with space)

        // 4. Clean up excessive whitespace that might result from removals
        cleaned = cleaned.replace(/\s\s+/g, ' '); // Replace multiple spaces with a single space

        return cleaned.trim(); // Trim leading/trailing whitespace
    }

    // ## NEW FUNCTION: Simple Language Guessing for TTS (Crucial Update!) ##
    /**
     * Attempts a basic guess of the language based on keywords to select the
     * correct TTS pronunciation engine.
     * @param {string} text The text to analyze.
     * @returns {string} The guessed BCP-47 language tag (e.g., 'sw-TZ', 'lg-UG', 'en-US').
     */
    function guessTextLanguage(text) {
        const lowerText = text.toLowerCase();
        
        // Swahili (sw) keywords: mambo, habari, asante, tafadhali, sijui, jambo
        if (lowerText.includes('mambo') || lowerText.includes('asante') || lowerText.includes('tafadhali') || lowerText.includes('swahili') || lowerText.includes('jambo') || lowerText.includes('habari')) {
            return 'sw-TZ'; // Swahili
        }

        // Luganda (lg) keywords: webale, otya, kye, kyokka, omulimu, oli otya
        if (lowerText.includes('webale') || lowerText.includes('otya') || lowerText.includes('luganda') || lowerText.includes('oli otya')) {
            return 'lg-UG'; // Luganda
        }

        // Hausa (ha) keywords: sannu, yaya, ina, me, Hausa, ina kwana
        if (lowerText.includes('sannu') || lowerText.includes('yaya') || lowerText.includes('hausa') || lowerText.includes('ina kwana')) {
            return 'ha-NG'; // Hausa
        }
        
        // Zulu/Xhosa (zu/xh) keywords: sawubona, yebo, ngiyabonga, zulu
        if (lowerText.includes('sawubona') || lowerText.includes('ngiyabonga') || lowerText.includes('zulu')) {
            return 'zu-ZA'; // Zulu
        }

        // Yoruba (yo) keywords: kaabo, e ku, kini, Yoruba
        if (lowerText.includes('kaabo') || lowerText.includes('e ku') || lowerText.includes('kini') || lowerText.includes('yoruba')) {
            return 'yo-NG'; // Yoruba
        }

        // Default to English if no clear non-English marker is found
        return 'en-US'; 
    }
    
    // ## TTS Functions (MODIFIED: speakText) ##
    function populateVoices() {
        voices = speechSynthesis.getVoices();
    }
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
    }

    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported in this browser.");
            return;
        }

        stopSpeaking();
        isSpeaking = true;
        stopSpeakingButton.style.display = 'block';

        const utterance = new SpeechSynthesisUtterance(text);

        // ðŸ”¥ CRITICAL UPDATE: Guess the language of the text
        const targetLangCode = guessTextLanguage(text);

        // MODIFIED: Change the voice tone (pitch) and rate (speed)
        utterance.pitch = 1.2; // Higher tone (e.g., 1.2)
        utterance.rate = 0.95; // Slightly slower speed (e.g., 0.95)

        // Enhanced Voice Selection for Multilingual/African Languages
   const voicePreferences = [
    // ðŸ”¥ PRIORITY 1: Highest Quality & Multilingual Voices (Best cross-device performance)
    // These are often the most attractive, natural, and device-independent voices.
    { name: 'Google', keyword: 'Multi' },
    { name: 'Microsoft', keyword: 'Multi' },
    { name: 'Amazon', keyword: 'Multi' },

    // PRIORITY 2: User's Preferred Defaults (Clear/Friendly Female & Professional Male)
    // By placing these immediately after the premium voices, you ensure they are the primary fallbacks 
    // and will be used regardless of the device (PC or Phone/Tablet).
    { name: 'Samantha', keyword: 'Samantha' }, // The preferred "clear, friendly" female voice.
    { name: 'Daniel', keyword: 'Daniel' },     // The preferred male voice.
    
    // PRIORITY 3: African-related languages (Explicit Regional Match)
    // Essential for the application's unique multilingual and regional focus.
    { lang: 'en-ZA', name: 'South African' }, 
    { lang: 'zu', name: 'Zulu' }, 
    { lang: 'sw', name: 'Swahili' }, 
    { lang: 'ha', name: 'Hausa' }
];
        let selectedVoice = null;
        
        // 1. Check for a voice that matches the GUESSED base language (e.g., find any voice with 'sw' language code for 'sw-TZ' text)
        const baseLang = targetLangCode.split('-')[0].toLowerCase();
        selectedVoice = voices.find(voice => voice.lang.split('-')[0].toLowerCase() === baseLang);
        
        // 2. Fallback to preferred voices if no exact language base match
        if (!selectedVoice) {
            for (let pref of voicePreferences) {
                // Find a voice by name OR by language code match
                selectedVoice = voices.find(voice => 
                    (voice.name.includes(pref.name || pref.keyword)) || 
                    (pref.lang && voice.lang.toLowerCase().includes(pref.lang.toLowerCase()))
                );
                if (selectedVoice) break;
            }
        }

        // Final fallback: any voice with an English language code
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.lang.includes('en'));
        }

        // If a voice is found, set it
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        // ðŸ”¥ CRITICAL FIX: Always set the utterance language to the GUESSED language code.
        // This is the most important step for correct pronunciation, even with an English voice.
        utterance.lang = targetLangCode; 


        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
        if (isSpeaking && 'speechSynthesis' in window) {
            speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    // ## STT Functions ##
    function initSpeechRecognition() {
        if (!SpeechRecognition) {
            console.warn("Speech Recognition not supported in this browser.");
            recordButton.disabled = true;
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false; // Capture a single phrase/sentence
        recognition.interimResults = false; // Only final results
        recognition.lang = africanLanguageCode; // Use the defined African language code

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            recordButton.title = 'Stop Recording (Listening)';
            chatInput.placeholder = 'ðŸŽ™ï¸ Listening... Speak now.';
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            chatInput.value = transcript;
            // Immediately send the query once transcription is complete
            typeQuery();
        };

        recognition.onerror = (event) => {
            console.error('Speech Recognition Error:', event.error);
            resetRecordingState();
            if (event.error === 'no-speech') {
                chatInput.placeholder = 'No speech detected. Try again.';
            } else if (event.error === 'not-allowed') {
                alert("Microphone access was denied. Please allow microphone permissions in your browser settings.");
            } else {
                 chatInput.placeholder = 'Error listening. Type or try again.';
            }
        };

        recognition.onend = () => {
            resetRecordingState();
        };
    }

    function resetRecordingState() {
        isRecording = false;
        recordButton.classList.remove('recording');
        recordButton.title = 'Start Recording';
        chatInput.placeholder = 'Type your question or tap the mic to speak...';
    }

    function toggleRecording() {
        if (!recognition) {
            initSpeechRecognition();
            if (!recognition) return; // Exit if init failed
        }
        
        if (isRecording) {
            recognition.stop();
        } else {
            // Stop any ongoing speech before starting a recording
            stopSpeaking(); 
            recognition.start();
        }
    }

    // ## Chat UI Functions ##
    function appendMessage(sender, text, isError = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender} ${isError ? 'error' : ''}`;
        
        if (sender === 'ai') {
            messageDiv.innerHTML = `<strong>Ai:</strong> <span class="text-gray-400"></span>`;
            const contentSpan = messageDiv.querySelector('span');
            chatLog.appendChild(messageDiv);
            
            // Typewriter effect
            let i = 0;
            function typeWriter() {
                if (i < text.length) {
                    contentSpan.textContent += text.charAt(i); 
                    i++;
                    setTimeout(typeWriter, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(text);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeWriter();
            
        } else {
            messageDiv.innerHTML = `<strong>You:</strong> ${text}`;
            chatLog.appendChild(messageDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    function addLoader() {
        const loaderDiv = document.createElement('div');
        loaderDiv.className = 'loader';
        loaderDiv.id = 'chatLoader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    function removeLoader() {
        const loader = document.getElementById('chatLoader');
        if (loader) {
            loader.remove();
        }
    }

    // ## API Interaction ##

    async function generateAiResponse(prompt) {
        // Prevent sending empty queries or if a query is already running
        if (!prompt || sendChatButton.disabled) {
            return;
        }
        
        // --- Limit Check ---
        if (responseCount >= responseLimit) {
            // Instead of blocking, show a warning and let the user decide.
            // For a production app, this would be a hard block. For this example, we warn but proceed.
            // console.warn("Response limit reached. Blocking API call.");
            // appendMessage('ai', "ðŸš¨ **Limit Warning:** You have reached your current response limit. Please upgrade or try again tomorrow.", true);
            // return;
        }
        
        appendMessage('user', prompt);
        chatInput.value = ''; // Clear input immediately
        sendChatButton.disabled = true; // Disable button
        addLoader();
        
        // 1. Convert history to API format
        const history = getChatHistory().map(item => ({
            // ðŸ”¥ FIX: Map local 'ai' role to API 'model' role ðŸ”¥
            role: item.role === 'ai' ? 'model' : item.role, 
            parts: [{ text: item.text }]
        }));

        // 2. Add the system instruction at the beginning
        let currentSystemInstruction = systemInstruction;
        
        // Inject the current local time and date
        if (userCurrentContext.currentTimeAndDate) {
            // Overwrite the placeholder date/time in the original instruction
            const [datePart, timePart] = userCurrentContext.currentTimeAndDate.split(', and the time is ');
            currentSystemInstruction = currentSystemInstruction.replace(/The user's accurate local date is \*\*(.*?)\*\*/, `The user's accurate local date is **${datePart}**`);
            currentSystemInstruction = currentSystemInstruction.replace(/The user's accurate local time is \*\*(.*?)\*\*/, `The user's accurate local time is **${timePart}**`);
        }
        
        // Inject the current location if available
        if (userCurrentContext.latitude && userCurrentContext.longitude) {
            // Inject the user's specific coordinates as context for the AI
            currentSystemInstruction += `\n- The user's specific coordinates are: **Lat ${userCurrentContext.latitude}, Lng ${userCurrentContext.longitude}**. Use this for location-aware requests and directions.`;
        }
        
        const fullContents = [{ role: "user", parts: [{ text: currentSystemInstruction }] }];
        
        // 3. Add relevant conversation history (last 10 messages)
        // This line is key for remembering older conversation context
        const relevantHistory = history.slice(-10); // Last 10 messages (5 turns)
        fullContents.push(...relevantHistory);
        
        // 4. Add the new user message
        fullContents.push({ role: 'user', parts: [{ text: prompt }] });

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: fullContents, 
                    // FIX VERIFIED: generationConfig is a top-level field
                    generationConfig: { 
                        temperature: 0.7,
                        maxOutputTokens: 2048
                    }
                })
            });

            if (!response.ok) {
                // Try to parse JSON for a detailed API error message
                let errorBody = null;
                try {
                    errorBody = await response.json();
                } catch (e) {
                    // Fallback if the body is not JSON (e.g., HTML error page, which causes the '<' token error)
                    throw new Error(`Non-JSON response (Status ${response.status}). Check server/proxy connection.`);
                }
                // If JSON parsing was successful, use the specific error message
                throw new Error(`API Error ${response.status}: ${errorBody.error?.message || 'Unknown API Error'}`);
            }

            const data = await response.json();
            
            const aiText = data.candidates?.[0]?.content?.parts?.[0]?.text || "I apologize, I could not generate a response. Please try again.";
            
            // Increment and save response count
            responseCount++;
            localStorage.setItem(responseCountKey, responseCount);
            
            removeLoader();
            // Append the raw AI text for typewriter effect (cleaning for speech later)
            appendMessage('ai', aiText); 
            
        } catch (error) {
            console.error('Gemini API Error:', error);
            removeLoader();
            // UPDATED ERROR MESSAGE as requested by the prompt:
            const errorMessage = `ðŸš¨ Could not connect to the AI service. Error: ${error.message}`;
            // Append cleaned error message
            appendMessage('ai', errorMessage, true); 
            // Speak the cleaned error message
            speakText(cleanText(errorMessage));
        } finally {
            sendChatButton.disabled = false; // Re-enable button
        }
    }

    // --- User Actions ---
    function typeQuery() {
        const query = chatInput.value.trim();
        
        if (!query) return;

        // ðŸ”¥ NEW LOGIC: Check for location-sharing keyword and trigger getUserLocation ðŸ”¥
        const lowerQuery = query.toLowerCase();
        if (lowerQuery.includes('share my location') || lowerQuery.includes('get my location') || lowerQuery.includes('update location')) {
            // Since this is a user action, append the user's message first
            appendMessage('user', query);
            
            // Clear the input and trigger the location request instead of the AI
            chatInput.value = ''; 
            getUserLocation();
            return; 
        }
        
        if (query) {
            generateAiResponse(query);
        }
    }

    function handleKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevents a new line in the textarea
            typeQuery();
        }
        // Optional: Auto-resize textarea
        chatInput.style.height = 'auto';
        chatInput.style.height = (chatInput.scrollHeight) + 'px';
    }

    function summarizeChat() {
        stopSpeaking(); // Stop current speech
        
        const history = getChatHistory();
        if (history.length === 0) {
            appendMessage('ai', "There is no conversation history to summarize.", true);
            return;
        }

        const summaryPrompt = "Please generate a concise, bullet-point summary of the key topics, concepts, and conclusions from the following conversation history. Respond in a professional, educational tone.";
        
        // Add a temporary loader message
        const loaderMsgDiv = document.createElement('div');
        loaderMsgDiv.className = 'chat-message ai';
        loaderMsgDiv.id = 'summaryLoader';
        loaderMsgDiv.innerHTML = '<strong>Ai (Summary):</strong> <div class="loader-small"></div> Generating summary...';
        chatLog.appendChild(loaderMsgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        
        // Prepare the conversation payload for the summary request
        const conversationContent = history.map(item => `${item.role.toUpperCase()}: ${item.text}`).join('\n');
        const summaryRequestContent = summaryPrompt + "\n\n--- Conversation History ---\n" + conversationContent;

        // FIX: Use the correct 'user' role for the system instruction and set up contents array
        const summaryContents = [
             { role: "user", parts: [{ text: systemInstruction }] },
             { role: "user", parts: [{ text: summaryRequestContent }] }
        ];

        // Send a dedicated API call for the summary
        fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: summaryContents, 
                // FIX VERIFIED: generationConfig is a top-level field
                generationConfig: { 
                    temperature: 0.2, // Lower temperature for factual summary
                    maxOutputTokens: 1024
                }
            })
        })
        .then(response => {
            if (!response.ok) {
                // Improved error handling for summarize
                return response.text().then(text => { // Read as text first
                    try {
                        const err = JSON.parse(text); // Try parsing as JSON
                        throw new Error(err.error?.message || `Status ${response.status}: Unknown API Error`);
                    } catch (e) {
                         // Non-JSON error (e.g., HTML response)
                        throw new Error(`Non-JSON response (Status ${response.status}). Check server/proxy connection.`);
                    }
                });
            }
            return response.json();
        })
        .then(data => {
            const displayText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Could not generate summary.";
            
            const loader = document.getElementById('summaryLoader');
            if (loader) { loader.remove(); }
            
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            
            // Create a span for the typewriter effect
            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            chatLog.appendChild(aiMsgDiv); // Append before starting the type effect
            
            let i = 0;
            function typeSummary() {
                if (i < displayText.length) { // Use uncleaned text for display
                    contentSpan.textContent += displayText.charAt(i); 
                    i++;
                    setTimeout(typeSummary, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(displayText);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeSummary();
            
        }) 
        .catch(error => {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             const summaryErrorText = "Could not generate summary due to a connection error: " + error.message;
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">ðŸš¨</span> ${cleanText(summaryErrorText)}`;
             chatLog.appendChild(errorMsgDiv);
             saveChatHistory();
             speakText("I encountered an error while generating the summary.");
        });
    }

    function exportChat() {
        const history = getChatHistory();
        if (history.length === 0) {
            alert("No chat history to export!");
            return;
        }

        let exportText = `LearnFlow AI Chat Export for ${username}\nDate: ${new Date().toLocaleString()}\n\n`;
        history.forEach(item => {
            exportText += `${item.role.toUpperCase()}: ${item.text}\n\n`;
        });

        const blob = new Blob([exportText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `learnflow_chat_${username}_${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function clearChat() {
        if (confirm("Are you sure you want to clear the entire chat history? This action cannot be undone.")) {
            localStorage.removeItem(chatHistoryKey);
            // Optionally, also clear the response count if the user is starting over fresh
            // localStorage.removeItem(responseCountKey);
            // responseCount = 0;
            
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Ai:</strong>
                    <span class="text-gray-400">
                        Chat history cleared. How can I help you start your learning journey today?
                    </span>
                </div>
            `;
            stopSpeaking();
            speakText("Chat history cleared. How can I help you start your learning journey today?");
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    // ## Local Storage Management ##

    function saveChatHistory() {
        const messages = [];
        // Only consider actual messages, not loaders or the initial welcome message from the template
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            const textContent = msgDiv.querySelector('span') ? msgDiv.querySelector('span').textContent.trim() : msgDiv.textContent.replace(role === 'user' ? 'You:' : 'Ai:', '').trim();
            
            if (textContent) {
                 messages.push({ role, text: textContent });
            }
        });

        // The save logic is slightly complex due to the typewriter effect. 
        // We will simplify by only saving the messages that are fully typed or user-sent messages.
        // For AI messages with the span, we'll use the span's content.

        // Re-implementing a safer save logic:
        const finalMessages = [];
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            let text = '';

            if (role === 'user') {
                // User messages are simple text
                text = msgDiv.textContent.replace('You:', '').trim();
            } else {
                // AI messages may have strong (role) and span (content)
                const contentSpan = msgDiv.querySelector('span');
                if (contentSpan) {
                     text = contentSpan.textContent.trim();
                } else {
                    // Fallback for AI messages without the span structure (like initial message)
                    text = msgDiv.textContent.replace('Ai:', '').trim();
                }
            }
            
            // Only save non-empty content (excluding the initial welcome text if it's still being typed)
            if (text) {
                 finalMessages.push({ role, text });
            }
        });

        localStorage.setItem(chatHistoryKey, JSON.stringify(finalMessages));
    }

    function getChatHistory() {
        const storedHistory = localStorage.getItem(chatHistoryKey);
        return storedHistory ? JSON.parse(storedHistory) : [];
    }

    function loadChatHistory() {
        const history = getChatHistory();
        chatLog.innerHTML = ''; // Clear the initial message template
        
        if (history.length === 0) {
            // Restore initial welcome message if history is empty
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <span class="text-gray-400">
                        Am here to help you learn in any language
                    </span>
                </div>
            `;
            return;
        }

        history.forEach(item => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${item.role}`;
            messageDiv.innerHTML = `<strong>${item.role === 'user' ? 'You' : 'Ai'}:</strong> ${item.text}`;
            chatLog.appendChild(messageDiv);
        });

        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Initialize
    window.onload = () => {
        loadChatHistory();
        initSpeechRecognition(); // Initialize recognition on page load
        
        // --- ADDED: Start the local time display ---
        updateAccurateLocalTime(); 
    };
</script>
{% endblock %}
