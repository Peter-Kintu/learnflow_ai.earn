{% extends "base.html" %}

{% block title %}Home - LearnFlow AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 90%; 
        margin: 2rem auto;
        background-color: #1f2937;
        border-radius: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 3rem;
        font-weight: 800;
        color: #ffffff;
        letter-spacing: -0.05em;
        line-height: 1.1;
    }

    .chat-header p {
        font-size: 1.125rem;
        color: #9ca3af;
        margin-top: 0.5rem;
        max-width: 32rem;
        margin-left: auto;
        margin-right: auto;
    }

    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; /* Stacks on small screens */
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh;
    }

    /* Message styling (same) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    .chat-message.user { justify-content: flex-end; align-self: flex-end; background-color: #4338ca; color: #e0e7ff; }
    .chat-message.ai { justify-content: flex-start; align-self: flex-start; background-color: #2d3748; color: #e5e7eb; }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }

    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* üî• UPDATED: Integrated Input Container for a cleaner look üî• */
    .integrated-input-container {
        display: flex;
        align-items: flex-end; /* Align items to the bottom, useful for growing textarea */
        width: 100%;
        background-color: #0a0e16; /* Darker background for more contrast */
        border-radius: 1rem; 
        border: 1px solid #4b5563;
        padding: 0.75rem; /* Increased padding */
        min-height: 4.5rem; /* Ensure minimum height for a good look */
    }

    /* üî• MODIFIED: Changed #chatInput to use <textarea> and updated styles üî• */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0.25rem 0.5rem; /* Less internal padding to make it look part of the container */
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; /* Slightly larger font */
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; /* Allow scrolling if it grows beyond max-height */
        min-height: 1.5rem; /* Min height of one line */
        max-height: 10rem; /* Limit max height to prevent takeover */
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; /* Ensure placeholder aligns properly */
    }
    
    #chatInput:focus {
        outline: none;
        box-shadow: 0 0 0 2px #4f46e5; /* Subtle blue focus glow on the container */
        /* Note: The focus style is often better applied to the *container* but is left here for simplicity */
    }

    /* --- ICON BUTTON Base Styling (for both mic and send) --- */
    .action-icon-button {
        flex-shrink: 0;
        width: 3rem; /* Slightly larger for better tap/click target */
        height: 3rem; 
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.5rem; /* Larger icon size */
        border-radius: 50%; /* Uniformly round buttons */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); /* Deeper shadow */
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.75rem; /* Increased separation */
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* üî• MODIFIED Send Button: Primary action, brighter color üî• */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.75rem;
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* Responsive adjustments for large screens (md: 768px and up) */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 80%; }
        .chat-area { flex-direction: row; min-height: 80vh; }
        #chatLog { width: 65%; min-height: 100%; max-height: 100%; border-radius: 0 0 0 1.5rem; padding: 1.5rem; }
        .chat-input-area { width: 35%; border-top: none; border-left: 1px solid #374151; border-radius: 0 0 1.5rem 0; flex-direction: column; justify-content: flex-start; }
        .button-group { flex-direction: column; gap: 1rem; }
        .action-button { flex: none; width: 100%; }
        .action-button.stop-speak { flex: none; width: 100%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white tracking-tight">
            Welcome, {{ user.username }} <span class="wave-emoji inline-block">üëã</span>
        </h1>
        <p class="text-base sm:text-lg text-gray-400 font-light">
            You‚Äôve joined LearnFlow AI, your powerful educational partner. 
        </p>
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Ai:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! 
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask LearnFlow AI 
            </h2>
            
            {# üî• MODIFIED: Changed input to TEXTAREA and buttons are larger üî• #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                
                <button onclick="typeQuery()" class="action-button send action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">üîá</span> Stop Speaking
                </button>
                
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput'); 
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton'); 

    const responseLimit = 3;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;
    
    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;
    
    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;

    // --- API Configuration ---
    // NOTE: Replace the placeholder with your actual Gemini API key.
    const apiKey = "AIzaSyBo-nakWm_HBUBStldTAKzcAdvB4OU46HU"; 
    const modelName = 'gemini-2.5-flash'; 
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

    /**
     * Cleans the AI response text by removing markdown formatting.
     * @param {string} text The raw text from the API.
     * @returns {string} The cleaned text.
     */
    function cleanText(text) {
        // Remove bold/italic markdown symbols
        let cleaned = text.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Removes ** or __ for bold
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Removes * or _ for italics
        return cleaned;
    }


    // ## TTS Functions (UNCHANGED) ##
    
    function populateVoices() {
        voices = speechSynthesis.getVoices();
    }
    
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
    }

    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported in this browser.");
            return;
        }

        stopSpeaking(); 

        isSpeaking = true;
        stopSpeakingButton.style.display = 'block'; 

        const cleanedText = cleanText(text); 

        const utterance = new SpeechSynthesisUtterance(cleanedText);
        
        const preferredVoices = [
            "Daniel", "Samantha", "Ting-Ting", 
            "Google US English", "Microsoft Zira" 
        ];

        let selectedVoice = null;
        for (let name of preferredVoices) {
            selectedVoice = voices.find(voice => voice.name.includes(name));
            if (selectedVoice) break;
        }
        
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.name.toLowerCase().includes('female') && voice.lang.includes('en'));
        }
        
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        utterance.rate = 1.0; 
        utterance.pitch = 1.0; 

        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none'; 
            if (!isRecording) {
                 // Removed voiceStatus update here since it's hidden, but keeping the logic intact
            }
        };
        
        utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
             if (!isRecording) {
                 // Removed voiceStatus update here since it's hidden, but keeping the logic intact
            }
        };

        speechSynthesis.speak(utterance);
    }
    
    function stopSpeaking() {
        if ('speechSynthesis' in window && speechSynthesis.speaking) {
            speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    // ## STT Functions (MODIFIED: recognition.onresult) ##

    function setupRecognition() {
        if (!SpeechRecognition) {
            // Updated status message for the new combined input
            chatInput.placeholder = "Voice input is not supported in this browser. Type your question here...";
            recordButton.disabled = true;
            return;
        }
        
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        recognition.lang = 'en-US';

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            chatInput.placeholder = "Listening... Speak clearly now."; // Use input placeholder for status
            stopSpeaking(); // Stop AI from talking when user starts speaking
        };

        // üî• MODIFIED: Put transcript into the input field instead of sending it directly üî•
        recognition.onresult = (event) => {
            const last = event.results.length - 1;
            const transcript = event.results[last][0].transcript;
            console.log("Transcript:", transcript);
            chatInput.value = transcript; // <-- THIS IS THE KEY CHANGE
            chatInput.placeholder = "Transcript ready. Tap Send or Enter to submit.";
            // The user must now press 'Send' or 'Enter'
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            recordButton.classList.remove('recording');
            isRecording = false;
            if (event.error !== 'no-speech') {
                chatInput.placeholder = `Error: ${event.error}. Tap the mic to try again.`;
            } else {
                 chatInput.placeholder = "Didn't catch that. Tap the mic or type your question here...";
            }
        };
        
        recognition.onend = () => {
            if (isRecording) {
                 recordButton.classList.remove('recording');
                 // Only reset placeholder if the transcript wasn't successful or sent
                 if (chatInput.value === '' || chatInput.placeholder.includes("Listening")) { 
                     chatInput.placeholder = "Tap the mic or type your question here...";
                 }
                 isRecording = false;
            }
        };
    }
    
    // Initialize recognition on load
    setupRecognition();

    function toggleRecording() {
        if (isRecording) {
            recognition.stop();
        } else {
            try {
                recognition.start();
            } catch (e) {
                 if (e.name !== 'InvalidStateError') {
                     console.error("Recording error:", e);
                     chatInput.placeholder = "Error starting mic. Check console/permissions.";
                 }
            }
        }
    }
    
    // NEW: Function to handle text input submission (Now handles both typed and voice-transcribed input)
    function typeQuery() {
        const query = chatInput.value.trim();
        if (query) {
            transcriptQuery(query);
            chatInput.value = ''; // Clear the input after sending
            chatInput.placeholder = "Tap the mic or type your question here..."; // Reset placeholder
            // Reset textarea height after clearing (important for auto-growing textarea)
            chatInput.style.height = 'auto'; 
        } else {
            console.warn("Input field is empty.");
        }
    }

    // NEW: Function to handle 'Enter' key press on the input field
    function handleKeydown(event) {
        // If shift or ctrl is pressed, allow for a new line instead of sending
        if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey) {
            typeQuery();
            event.preventDefault(); 
        } else if (event.key === 'Enter' && (event.shiftKey || event.ctrlKey)) {
            // Allows Shift+Enter or Ctrl+Enter for a new line
            // The auto-growing textarea handles the height change
        }
    }
    
    // Function to handle auto-growing textarea
    function autoGrowTextarea() {
        chatInput.style.height = 'auto';
        chatInput.style.height = chatInput.scrollHeight + 'px';
    }

    // Attach listeners on load
    document.addEventListener('DOMContentLoaded', () => {
        chatInput.addEventListener('keydown', handleKeydown);
        chatInput.addEventListener('input', autoGrowTextarea); // Attach autogrow listener
        autoGrowTextarea(); // Set initial height
    });
    
    // OLD: Renamed sendChat to transcriptQuery for voice input workflow, now handles text input too (UNCHANGED logic)
    async function transcriptQuery(query) {
        if (!query.trim()) {
            // Removed voiceStatus update, using console.warn
            return;
        }

        stopSpeaking(); // Ensure AI stops speaking if user interrupts
        
        // Display user message
        const userMsgDiv = document.createElement('div');
        userMsgDiv.className = "chat-message user";
        userMsgDiv.innerHTML = `<strong>You:</strong> ${query}`;
        chatLog.appendChild(userMsgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        saveChatHistory();
        
        // Rate Limit Check
        if (responseCount >= responseLimit) {
            const upgradeMsg = "You've reached your free chat limit! Please upgrade for unlimited access.";
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai error"; 
            aiMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">üîí</span> ${upgradeMsg}`;
            chatLog.appendChild(aiMsgDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText(upgradeMsg); // Speak the error message
            return;
        }

        const loaderDiv = document.createElement('div');
        loaderDiv.id = 'loader';
        loaderDiv.className = 'loader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;

        try {
            const conversationHistory = getConversationHistory();
            
            const payload = {
                contents: [
                    ...conversationHistory, 
                    { role: 'user', parts: [{ text: query }] } 
                ]
            };

            const response = await fetch(apiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            
            const data = await response.json();
            
            const loader = document.getElementById('loader');
            if (loader) { loader.remove(); }
            
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai"; 
            chatLog.appendChild(aiMsgDiv);
            
            let fullText = "No response received. Please check the console (F12) for API errors.";
            let isError = false;

            if (data?.candidates?.[0]?.content?.parts?.length) {
                fullText = data.candidates[0].content.parts.map(p => p.text).join("\n\n");
            } else if (data.error) {
                 fullText = `API Error: ${data.error.message || "An unknown API error occurred."}`;
                 isError = true;
            } else if (data.promptFeedback?.blockReason) {
                 fullText = `Response blocked. Reason: ${data.promptFeedback.blockReason}`;
                 isError = true;
            }

            // CLEAN THE TEXT BEFORE TYPING
            const displayAndSpeakText = cleanText(fullText);

            if (isError) {
                aiMsgDiv.classList.add('error');
                aiMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">üö´</span> ${displayAndSpeakText}`;
                saveChatHistory();
                speakText("I encountered an error. " + displayAndSpeakText); 
            } else {
                // Pass the cleaned text to typeWriter
                typeWriter(aiMsgDiv, displayAndSpeakText); 
                responseCount++;
            }
            
            chatLog.scrollTop = chatLog.scrollHeight;
            
        } catch (error) {
            console.error("Fetch/Network Error:", error);
            const loader = document.getElementById('loader');
            if (loader) { loader.remove(); }
            
            const errorMsgDiv = document.createElement('div');
            errorMsgDiv.className = "chat-message error"; 
            const errorText = "Network Error. Could not reach the server.";
            errorMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">üö®</span> ${errorText}`;
            chatLog.appendChild(errorMsgDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText("I encountered a network error.");
        }
    }

    // ## Core Chat/API Functions (UNCHANGED) ##

    // Load chat history from localStorage on page load
    document.addEventListener('DOMContentLoaded', () => {
        const storedChat = localStorage.getItem(chatHistoryKey);
        stopSpeakingButton.style.display = 'none';

        if (storedChat) {
            chatLog.innerHTML = storedChat;
            // Existing logic to handle old class names... (omitted for brevity, assume it runs)
            
            // Re-check if the initial welcome message is missing and add it back
            if (!chatLog.innerHTML.includes("educational assistant powered by the Gemini Flash model")) {
                chatLog.innerHTML = `
                    <div class="chat-message ai">
                        <strong>Ai:</strong>
                        <span class="text-gray-400">
                            Hello, {{ user.username }}! 
                        </span>
                    </div>` + chatLog.innerHTML;
            } 
            
            chatLog.scrollTop = chatLog.scrollHeight;
        } else {
             // Add initial welcome message if no history exists
             chatLog.innerHTML = `
                 <div class="chat-message ai">
                     <strong>Ai:</strong> 
                 <span class="text-gray-400">
                     Hello, {{ user.username }}! 
                 </span>
                 </div>`;
        }
    });

    function saveChatHistory() {
        localStorage.setItem(chatHistoryKey, chatLog.innerHTML);
        localStorage.setItem(responseCountKey, responseCount);
    }

    // Typing animation function - **Now calls speakText on completion with CLEANED text**
    function typeWriter(element, text, speed = 10) {
        let i = 0;
        element.innerHTML = `<strong>Ai:</strong> `;
        const contentSpan = document.createElement('span');
        element.appendChild(contentSpan);

        function type() {
            if (i < text.length) {
                contentSpan.textContent += text.charAt(i); 
                i++;
                setTimeout(type, speed);
            } else {
                saveChatHistory();
                speakText(text); // <-- Speak the already cleaned text after typing
            }
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        type();
    }
    
    // Function to extract conversation history in API format
    function getConversationHistory() {
        const history = [];
        const children = Array.from(chatLog.children);

        for (const child of children) {
            const isUser = child.classList.contains('user');
            const isAI = child.classList.contains('ai');
            
            if (child.classList.contains('error') || child.id === 'loader' || child.id === 'summaryLoader' || child.innerText.includes("educational assistant powered by the Gemini Flash model")) {
                continue;
            }

            if (isUser) {
                const text = child.textContent.replace('You:', '').trim(); 
                history.push({ role: 'user', parts: [{ text: text }] });
            } else if (isAI) {
                // Clean up all possible AI prefixes
                const text = child.textContent
                             .replace('Ai (Summary):', '')
                             .replace('Ai:', '')
                             .replace('Summary:', '')
                             .trim();
                             
                // Remove formatting from the content being sent back to the API for context
                const cleanedTextForAPI = cleanText(text);

                if (cleanedTextForAPI) { history.push({ role: 'model', parts: [{ text: cleanedTextForAPI }] }); }
            }
        }
        return history;
    }

    // Function to clear the chat history and the chat log display
    function clearChat() {
        stopSpeaking(); 
        chatLog.innerHTML = '';
        localStorage.removeItem(chatHistoryKey);
        responseCount = 0;
        localStorage.setItem(responseCountKey, '0');
        // Re-add the welcome message
        chatLog.innerHTML = `
             <div class="chat-message ai">
                 <strong>Ai:</strong> 
                 <span class="text-gray-400">
                     Hello, {{ user.username }}! 
                 </span>
             </div>`;
    }

    function exportChat() {
        stopSpeaking(); 
        const plainText = chatLog.innerText;
        const blob = new Blob([plainText], { type: 'text/plain;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'LearnFlow_Chat_Transcript.txt'; 
        link.click();
    }
    
    // Summarize function - **Now uses cleanText on completion**
    async function summarizeChat() {
        stopSpeaking(); 
        
        const conversationHistory = getConversationHistory();
        
        const historyForSummary = conversationHistory.filter(message => 
            !message.parts[0].text.includes("Please provide a concise, numbered summary of the previous conversation")
        );

        if (historyForSummary.length === 0) {
            const warningMsgDiv = document.createElement('div');
            const noSummaryText = "No conversation to summarize. Start chatting!";
            warningMsgDiv.className = "chat-message error";
            warningMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">‚ö†Ô∏è</span> ${noSummaryText}`;
            chatLog.appendChild(warningMsgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText(noSummaryText); 
            return;
        }

        const loaderDiv = document.createElement('div');
        loaderDiv.id = 'summaryLoader';
        loaderDiv.className = 'loader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;

        const summaryPrompt = "Please provide a concise, numbered summary of the previous conversation. Focus on the main topics and conclusions. Address the user directly as 'you'.";

        const payload = {
            contents: [
                ...historyForSummary, 
                { role: 'user', parts: [{ text: summaryPrompt }] } 
            ]
        };

        try {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });

            const data = await response.json();

            const loader = document.getElementById('summaryLoader');
            if (loader) { loader.remove(); }

            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            chatLog.appendChild(aiMsgDiv);

            let fullText = data.candidates?.[0]?.content?.parts?.[0]?.text || "No summary available. Check console for API errors.";
            
            // CLEAN THE TEXT BEFORE TYPING AND SPEAKING
            const displayAndSpeakText = cleanText(fullText);

            aiMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> `;
            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            
            let i = 0;
            function typeSummary() {
                if (i < displayAndSpeakText.length) {
                    contentSpan.textContent += displayAndSpeakText.charAt(i); 
                    i++;
                    setTimeout(typeSummary, 10);
                } else {
                    saveChatHistory();
                    speakText(displayAndSpeakText); // <-- Speak the cleaned summary
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeSummary();
            
        } catch (error) {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             const summaryErrorText = "Could not generate summary due to a connection error.";
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">üö®</span> ${summaryErrorText}`;
             chatLog.appendChild(errorMsgDiv);
             saveChatHistory();
        }
    }
</script>
{% endblock %}