{% extends "base.html" %}

{% block title %}Home - Praise AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* NEW: Neutral selection colors for cleaner copy/paste (Browser dependent) */
    ::selection {
      background: #4f46e5;
      color: #ffffff;
    }
    .chat-message.ai::selection {
        background: #4f46e5;
        color: #ffffff;
    }
    .chat-message.user::selection {
        background: #4f46e5;
        color: #ffffff;
    }
    
    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 98%; /* Wider for small screens */
        margin: 1rem auto;
        background-color: #1f2937;
        border-radius: 1.0rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
        box-sizing: border-box; /* Ensures padding/border doesn't cause overflow */
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 2rem;
        font-weight: 700;
        color: #ffffff;
        letter-spacing: -0.02em;
        line-height: 1.1;
    }
    
    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; 
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh; /* Base height for small screens */
    }

    /* Message styling (MODERNIZED) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    
    /* MODIFIED: User message to brighter indigo with a subtle lift */
    .chat-message.user { 
        justify-content: flex-end; 
        align-self: flex-end; 
        background-color: #6366f1; 
        color: #ffffff; 
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); 
    }
    
    /* MODIFIED: AI message to softer dark background with a modern accent bar */
    .chat-message.ai { 
        justify-content: flex-start; 
        align-self: flex-start; 
        background-color: #1a222e; 
        color: #e5e7eb; 
        border-left: 4px solid #4f46e5; 
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3); 
    }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }
    
    /* NEW: Code Block Styling (Addresses Clean Code Formatting) */
    .chat-message pre {
        background-color: #0a0e16; 
        color: #e5e7eb; 
        padding: 1rem;
        border-radius: 0.5rem;
        overflow-x: auto; 
        font-family: 'Consolas', 'Courier New', monospace; 
        border: 1px solid #4b5563; 
        width: 100%; 
        box-sizing: border-box; 
        white-space: pre; 
        word-wrap: normal; 
    }

    .chat-message code {
        font-family: 'Consolas', 'Courier New', monospace;
        background-color: transparent; 
        padding: 0;
        color: #10b981; 
    }
    
    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* MODIFIED: Integrated Input Container - Tighter vertical padding */
    .integrated-input-container {
        display: flex;
        align-items: center; 
        width: 100%;
        background-color: #0a0e16; 
        border-radius: 1.0rem; 
        border: 1px solid #4b5563;
        padding: 0.5rem 0.5rem; 
        transition: border-color 0.3s, box-shadow 0.3s; 
        box-sizing: border-box; /* Input fix */
    }
    
    /* NEW: Add a visual focus state to the container */
    .integrated-input-container:focus-within {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #4f46e5;
    }

    /* MODIFIED: #chatInput - Still no padding, maximizes space */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0; 
        padding-right: 0.5rem; /* Add small padding inside text area */
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; 
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; 
        min-height: 1.5rem; 
        max-height: 10rem; 
        word-wrap: break-word; /* Input fix */
        overflow-wrap: break-word; /* Input fix */
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; 
    }
    
    #chatInput:focus {
        outline: none; 
        box-shadow: none;
    }

    /* ðŸ”¥ MODIFIED: ICON BUTTON Base Styling - Reduced size for more input space ðŸ”¥ */
    .action-icon-button {
        flex-shrink: 0; 
        width: 2.5rem; 
        height: 2.5rem; 
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.2rem; 
        border-radius: 50%; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.25rem; 
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* MODIFIED Send Button */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.25rem; 
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* ðŸ”¥ MODIFIED: Responsive adjustments for large screens (md: 768px and up) ðŸ”¥ */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 90%; min-height: 95vh; } /* Wider and taller on large screen */
        
        #chatLog { 
            width: auto; 
            min-height: 75vh; /* Increased chat area for large screens */
            max-height: 75vh; 
            border-radius: 0; 
            padding: 1.5rem; 
        }
        
        /* Input area now spans full width at the bottom: */
        .chat-input-area { 
            width: auto; 
            border-top: 1px solid #374151; 
            border-left: none; 
            border-radius: 0 0 1.5rem 1.5rem; 
            flex-direction: column; 
            justify-content: flex-start; 
        }

        /* Adjusted button group layout for larger screens: */
        .button-group { 
            flex-direction: row; 
            gap: 1rem; 
        }
        .action-button { 
            flex: 1; 
            max-width: 25%; 
        }
        .action-button.stop-speak { flex: 1; max-width: 25%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        
        <h1 class="text-2xl sm:text-3xl font-extrabold text-white tracking-tight">

            Hello {{ user.username }}, hope you're fine <span class="wave-emoji inline-block">ðŸ‘‹</span>
        </h1>
        <p id="localTimeDisplay" class="text-lg text-indigo-300 mt-1 font-medium"></p>
        
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Praise AI:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! I'm Praise AI, your enthusiastic and modern learning guide. What fascinating topic are we exploring today?
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask Praise AI 
            </h2>
            
            {# MODIFIED: Buttons are now smaller, input area is wider #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                
                <button onclick="typeQuery()" class="action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">ðŸ”‡</span> Stop Speaking
                </button>
                
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>

</div>




<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput'); 
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton'); 

    const responseLimit = 10;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;
    
    // ðŸ”¥ NEW GLOBAL VARIABLE: To store and pass the user's accurate context to the AI ðŸ”¥
    let userCurrentContext = {};
    
    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;
    
    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;
    
    // ðŸ”¥ NEW CONSTANT: Set the African Language Code for Speech Recognition (STT) ðŸ”¥
    // Swahili (Tanzania) is generally the most robust African language supported by Chrome/browser STT.
    // Try other codes like 'ha-NG' (Hausa) or 'zu-ZA' (Zulu) if you prefer.
    const africanLanguageCode = 'sw-TZ'; 

    // --- API Configuration ---
    // NOTE: Replace the placeholder with your actual Gemini API key.
  
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== '') {
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
      let cookie = cookies[i].trim();
      if (cookie.startsWith(name + '=')) {
        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}

const proxyUrl = "/api/gemini_proxy/";

async function sendMessage(finalMessages) {
  const response = await fetch(proxyUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      contents: finalMessages,
      config: { temperature: 0.7, maxOutputTokens: 512 }
    })
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}));
    throw new Error(errorBody.error || `HTTP error! Status: ${response.status}`);
  }

  const data = await response.json();

  // Always use the simplified text field returned by the proxy
  const text = data.text || "[No text returned]";
  return text;
}

    // ðŸ”¥ MODIFIED: systemInstruction - Updated for Modern Persona and Engagement ðŸ”¥
    const systemInstruction = `You are ** AI**, a modern, enthusiastic, and globally-aware educational guide developed by Kintu Peter. Your primary goal is to make learning engaging, personal, and fun for all users. Always maintain a warm, encouraging, and highly professional tone.

**INSTRUCTIONS FOR CONTEXT HANDLING:**
1. **ACCURATE USER CONTEXT:** The **CURRENT CONTEXT** section below will be dynamically updated by the user's browser (NOT by you). If a **Latitude/Longitude** is present, the user has explicitly shared their location, and you **MUST** use it for location-aware requests (like weather, directions, or local information).
2. **LOCATION LINK:** When location is successfully obtained, you **ARE PERMITTED** to provide a Google Maps URL for the user's current coordinates using the format: [View on Map](https://www.google.com/maps/search/?api=1&query=LAT,LNG).
3. **FALLBACK:** If no Latitude/Longitude is provided, use your **Virtual Location** (Kampala, Uganda) as a default.
4. **PRIVACY:** If the user asks *why* you know their location, state that it was explicitly provided by the browser after the user clicked 'Share Location.'
5. **TIME/DATE:** Always use the accurate time and date from the CURRENT CONTEXT when asked.

CURRENT CONTEXT:
- The user's accurate local date is **Friday, October 17, 2025**.
- The user's accurate local time is **9:04 PM EAT**.
- Your current virtual location is **Kampala, Uganda**.

**INSTRUCTIONS FOR REAL-TIME DATA & PREDICTIONS:**
- If the user asks for **real-time information (like news or current scores)**, use your internal browsing/search capability to provide the most current and accurate answer, acknowledging the inherent latency in news.
- If the user asks for **match predictions (e.g., football, soccer)**, use your vast knowledge base and current data to provide a detailed analysis and a most likely outcome, acting as an expert sports analyst.

**INSTRUCTIONS FOR CODE/HTML:**
- When providing code, use **markdown code blocks** (e.g., \`\`\`html) for clean, copy-pasteable output.
- When the user pastes or asks about HTML code, advise them that their input is safely displayed as **text** in the chat (not rendered) for security and clean editing.

Always respond in the language the user is using, maintaining context and educational quality.`;
    
    // --- Function to get and display accurate local date/time ---
    function updateAccurateLocalTime() {
        const now = new Date();
        
        // Format the date (e.g., Friday, December 6, 2025)
        const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        const dateString = now.toLocaleDateString(undefined, dateOptions);

        // Format the time (e.g., 9:04 PM EAT)
        const timeOptions = { hour: '2-digit', minute: '2-digit', hour12: true, timeZoneName: 'short' };
        const timeString = now.toLocaleTimeString(undefined, timeOptions);
        
        // This is the accurate, user-local time and date for the AI context
        const localTimeText = `${dateString}, and the time is ${timeString}`; 
        
        // Update the global context variable
        userCurrentContext.currentTimeAndDate = localTimeText;
        
        // ðŸ”¥ UPDATE: Update the display element in the header
        const displayElement = document.getElementById('localTimeDisplay');
        if (displayElement) {
            displayElement.textContent = `Your local time: ${timeString} on ${dateString}`;
        }
        
        // Re-run every second to keep time accurate
        setTimeout(updateAccurateLocalTime, 1000); 
    }

    // --- Function to get the user's coordinates and pass them to the AI ---
    function getUserLocation() {
        // 1. Check if the browser supports the Geolocation API
        if ("geolocation" in navigator) {
            
            // Options for accuracy and timeout (as requested: high accuracy)
            const options = {
                enableHighAccuracy: true, // Request the best possible result (more accurate)
                timeout: 5000,            // Maximum time to wait for a result (5 seconds)
                maximumAge: 0             // Do not use a cached position
            };

            // 2. Request the user's current position (will trigger a permission prompt)
            // Note: We already appended the user's query in typeQuery()
            appendMessage('ai', 'Waiting for location permission...');
            
            navigator.geolocation.getCurrentPosition(
                // Success Callback: position is available
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    // Update global context
                    userCurrentContext.latitude = lat;
                    userCurrentContext.longitude = lng;
                    
                    // STICKING TO THE INSTRUCTION'S FORMAT:
                    const mapLink = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`;
                    const mapLinkMarkdown = `[View Your Location on Google Maps](${mapLink})`;
                    // 3. Inform the user in the chat (NOW INCLUDES LINK)
                    const aiMessage = `Location update successful! Your coordinates (Lat: ${lat.toFixed(4)}, Lng: ${lng.toFixed(4)}) have been saved with an accuracy of ${accuracy.toFixed(0)} meters. I will now use this for location-aware queries and directions.

${mapLinkMarkdown}

Please proceed with your location-based query (e.g., "What is the weather like here?").`;
                    
                    // Use the existing 'appendMessage' function to speak the message
                    appendMessage('ai', aiMessage); 
                },
                // Error Callback: handles when the user denies permission or an error occurs
                (error) => {
                    console.error("Error getting user location:", error.code, error.message);
                    
                    let errorMessage = "Unable to retrieve your location.";
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = "Location access was denied. Please allow location sharing in your browser settings and try again.";
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = "Timed out while trying to get location. Try again.";
                    } else {
                         errorMessage = `Location error (${error.code}): ${error.message}`;
                    }
                    
                    // Show error message to the user in the chat log (using existing function)
                    appendMessage('ai', errorMessage, true);
                },
                options // Pass the options object for high accuracy
            );
        } else {
            // Geolocation is not supported by the browser
            const notSupportedMsg = "Error: Your browser doesn't support geolocation.";
            appendMessage('ai', notSupportedMsg, true);
        }
    }


    /**
     * Cleans the AI response text by removing markdown formatting and disruptive symbols
     * before text-to-speech conversion.
     * @param {string} text The raw text from the API.
     * @returns {string} The cleaned text.
     */
    function cleanText(text) {
        let cleaned = text;

        // 1. Remove link/citation brackets and their content
        cleaned = cleaned.replace(/\[(.*?)\]/g, '$1'); // Keep content content inside brackets, remove brackets themselves (e.g. for [text](link))

        // 2. Remove common markdown bold/italic/strikethrough symbols (**, *, __, _, ~~).
        cleaned = cleaned.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Removes ** and __ for bold/strong
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Removes * and _ for italics/emphasis
        cleaned = cleaned.replace(/~~(.*?)~~/g, '$1'); // Removes ~~ for strikethrough

        // 3. Remove list markers, headings, and specific disruptive punctuation (like " and lone *)
        cleaned = cleaned.replace(/^\s*[-*]+\s+/gm, ''); // Removes list markers: -, *, --, etc. at the start of a line
        cleaned = cleaned.replace(/#+\s*/g, ''); // Removes heading symbols (e.g., #, ##, ###)
        cleaned = cleaned.replace(/"/g, ''); // Remove all double quotes (user requested)
        cleaned = cleaned.replace(/---/g, ' '); // Remove triple dashes (horizontal rule)
        cleaned = cleaned.replace(/--/g, ' '); // Remove double dashes (en/em dashes)
        cleaned = cleaned.replace(/-/g, ' '); // Remove remaining single hyphens (user requested, replace with space)

        // 4. Clean up excessive whitespace that might result from removals
        cleaned = cleaned.replace(/\s\s+/g, ' '); // Replace multiple spaces with a single space
        
        // 5. Specifically remove code blocks entirely for speech synthesis
        cleaned = cleaned.replace(/```.*?```/gs, ' Code block output is not spoken. ');


        return cleaned.trim(); // Trim leading/trailing whitespace
    }

    // ## NEW FUNCTION: Simple Language Guessing for TTS (Crucial Update!) ##
    /**
     * Attempts a basic guess of the language based on keywords to select the
     * correct TTS pronunciation engine.
     * @param {string} text The text to analyze.
     * @returns {string} The guessed BCP-47 language tag (e.g., 'sw-TZ', 'lg-UG', 'en-US').
     */
    function guessTextLanguage(text) {
        const lowerText = text.toLowerCase();
        
        // Swahili (sw) keywords: mambo, habari, asante, tafadhali, sijui, jambo
        if (lowerText.includes('mambo') || lowerText.includes('asante') || lowerText.includes('tafadhali') || lowerText.includes('swahili') || lowerText.includes('jambo') || lowerText.includes('habari')) {
            return 'sw-TZ'; // Swahili
        }

        // Luganda (lg) keywords: webale, otya, kye, kyokka, omulimu, oli otya
        if (lowerText.includes('webale') || lowerText.includes('otya') || lowerText.includes('luganda') || lowerText.includes('oli otya')) {
            return 'lg-UG'; // Luganda
        }

        // Hausa (ha) keywords: sannu, yaya, ina, me, Hausa, ina kwana
        if (lowerText.includes('sannu') || lowerText.includes('yaya') || lowerText.includes('hausa') || lowerText.includes('ina kwana')) {
            return 'ha-NG'; // Hausa
        }
        
        // Zulu/Xhosa (zu/xh) keywords: sawubona, yebo, ngiyabonga, zulu
        if (lowerText.includes('sawubona') || lowerText.includes('ngiyabonga') || lowerText.includes('zulu')) {
            return 'zu-ZA'; // Zulu
        }

        // Yoruba (yo) keywords: kaabo, e ku, kini, Yoruba
        if (lowerText.includes('kaabo') || lowerText.includes('e ku') || lowerText.includes('kini') || lowerText.includes('yoruba')) {
            return 'yo-NG'; // Yoruba
        }

        // Default to English if no clear non-English marker is found
        return 'en-US'; 
    }
    
    // ## TTS Functions (MODIFIED: speakText) ##
    function populateVoices() {
        voices = speechSynthesis.getVoices();
    }
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
    }

    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported in this browser.");
            return;
        }

        stopSpeaking();
        isSpeaking = true;
        stopSpeakingButton.style.display = 'block';

        const utterance = new SpeechSynthesisUtterance(text);

        // ðŸ”¥ CRITICAL UPDATE: Guess the language of the text
        const targetLangCode = guessTextLanguage(text);

        // MODIFIED: Change the voice tone (pitch) and rate (speed)
        utterance.pitch = 1.2; // Higher tone (e.g., 1.2)
        utterance.rate = 0.95; // Slightly slower speed (e.g., 0.95)

        // Enhanced Voice Selection for Multilingual/African Languages (Now Male-Only Preference)
   const voicePreferences = [
    // ðŸ”¥ PRIORITY 1: EXPLICIT MALE VOICE (Daniel) - Removed Samantha
    { name: 'Daniel', keyword: 'Daniel' },     // The preferred male voice.
    
    // PRIORITY 2: Highest Quality & Neutral Voices (Best cross-device performance)
    { name: 'Google', keyword: 'Multi' },
    { name: 'Microsoft', keyword: 'Multi' },
    { name: 'Amazon', keyword: 'Multi' },
    
    // PRIORITY 3: African-related languages (Explicit Regional Match)
    { lang: 'en-ZA', name: 'South African' }, 
    { lang: 'zu', name: 'Zulu' }, 
    { lang: 'sw', name: 'Swahili' }, 
    { lang: 'ha', name: 'Hausa' }
];
// NOTE: The female voice ('Samantha') has been removed to ensure an exclusively male/neutral voice selection.
        let selectedVoice = null;
        
        // 1. Check for a voice that matches the GUESSED base language (e.g., find any voice with 'sw' language code for 'sw-TZ' text)
        const baseLang = targetLangCode.split('-')[0].toLowerCase();
        selectedVoice = voices.find(voice => voice.lang.split('-')[0].toLowerCase() === baseLang);
        
        // 2. Fallback to preferred voices if no exact language base match
        if (!selectedVoice) {
            for (let pref of voicePreferences) {
                // Find a voice by name OR by language code match
                selectedVoice = voices.find(voice => 
                    (voice.name.includes(pref.name || pref.keyword)) || 
                    (pref.lang && voice.lang.toLowerCase().includes(pref.lang.toLowerCase()))
                );
                if (selectedVoice) break;
            }
        }

        // Final fallback: any voice with an English language code
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.lang.includes('en'));
        }

        // If a voice is found, set it
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        // ðŸ”¥ CRITICAL FIX: Always set the utterance language to the GUESSED language code.
        // This is the most important step for correct pronunciation, even with an English voice.
        utterance.lang = targetLangCode; 


        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        utterance.onerror = (event) => {
            console.error('SpeechSynthesisUtterance.onerror', event);
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        speechSynthesis.speak(utterance);
    }

    function stopSpeaking() {
        if (isSpeaking && 'speechSynthesis' in window) {
            speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    // ## STT Functions ##
    function initSpeechRecognition() {
        if (!SpeechRecognition) {
            console.warn("Speech Recognition not supported in this browser.");
            recordButton.disabled = true;
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false; // Capture a single phrase/sentence
        recognition.interimResults = false; // Only final results
        recognition.lang = africanLanguageCode; // Use the defined African language code

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            recordButton.title = 'Stop Recording (Listening)';
            chatInput.placeholder = 'ðŸŽ™ï¸ Listening... Speak now.';
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            chatInput.value = transcript;
            // Immediately send the query once transcription is complete
            typeQuery();
        };

        recognition.onerror = (event) => {
            console.error('Speech Recognition Error:', event.error);
            resetRecordingState();
            if (event.error === 'no-speech') {
                chatInput.placeholder = 'No speech detected. Try again.';
            } else if (event.error === 'not-allowed') {
                alert("Microphone access was denied. Please allow microphone permissions in your browser settings.");
            } else {
                 chatInput.placeholder = 'Error listening. Type or try again.';
            }
        };

        recognition.onend = () => {
            resetRecordingState();
        };
    }

    function resetRecordingState() {
        isRecording = false;
        recordButton.classList.remove('recording');
        recordButton.title = 'Start Recording';
        chatInput.placeholder = 'Type your question or tap the mic to speak...';
    }

    function toggleRecording() {
        if (!recognition) {
            initSpeechRecognition();
            if (!recognition) return; // Exit if init failed
        }
        
        if (isRecording) {
            recognition.stop();
        } else {
            // Stop any ongoing speech before starting a recording
            stopSpeaking(); 
            recognition.start();
        }
    }

    // ## Chat UI Functions ##
    function appendMessage(sender, text, isError = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender} ${isError ? 'error' : ''}`;
        
        if (sender === 'ai') {
            messageDiv.innerHTML = `<strong>Ai:</strong> <span class="text-gray-400"></span>`;
            const contentSpan = messageDiv.querySelector('span');
            chatLog.appendChild(messageDiv);
            
            // Typewriter effect
            let i = 0;
            function typeWriter() {
                if (i < text.length) {
                    contentSpan.textContent += text.charAt(i); 
                    i++;
                    setTimeout(typeWriter, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(text);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeWriter();
            
        } else {
            // ðŸ”¥ CRITICAL FIX: Use textContent for user messages to prevent HTML rendering (XSS) ðŸ”¥
            messageDiv.innerHTML = `<strong>You:</strong> `;
            const textNode = document.createTextNode(text);
            messageDiv.appendChild(textNode);
            
            chatLog.appendChild(messageDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    function addLoader() {
        const loaderDiv = document.createElement('div');
        loaderDiv.className = 'loader';
        loaderDiv.id = 'chatLoader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    function removeLoader() {
        const loader = document.getElementById('chatLoader');
        if (loader) {
            loader.remove();
        }
    }

    // ## API Interaction ##

    async function generateAiResponse(prompt) {
  if (!prompt || sendChatButton.disabled) return;

  appendMessage('user', prompt);
  chatInput.value = '';
  sendChatButton.disabled = true;
  addLoader();

  const history = getChatHistory().map(item => ({
    role: item.role === 'ai' ? 'model' : item.role,
    parts: [{ text: item.text }]
  }));

  let currentSystemInstruction = systemInstruction;

  if (userCurrentContext.currentTimeAndDate) {
    const [datePart, timePart] = userCurrentContext.currentTimeAndDate.split(', and the time is ');
    currentSystemInstruction = currentSystemInstruction.replace(/The user's accurate local date is \*\*(.*?)\*\*/, `The user's accurate local date is **${datePart}**`);
    currentSystemInstruction = currentSystemInstruction.replace(/The user's accurate local time is \*\*(.*?)\*\*/, `The user's accurate local time is **${timePart}**`);
  }

  if (userCurrentContext.latitude && userCurrentContext.longitude) {
    currentSystemInstruction += `\n- The user's specific coordinates are: **Lat ${userCurrentContext.latitude}, Lng ${userCurrentContext.longitude}**. Use this for location-aware requests and directions.`;
  }

  const fullContents = [
    { role: "user", parts: [{ text: currentSystemInstruction }] },
    ...history.slice(-10),
    { role: "user", parts: [{ text: prompt }] }
  ];

  try {
    const response = await fetch(proxyUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify({
        contents: fullContents,
        config: { temperature: 0.7, maxOutputTokens: 2048 }
      })
    });

    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({}));
      throw new Error(errorBody.error || `HTTP error! Status: ${response.status}`);
    }

    const data = await response.json();
    const aiText = data.text || "I apologize, I could not generate a response.";

    responseCount++;
    localStorage.setItem(responseCountKey, responseCount);

    removeLoader();
    appendMessage('ai', aiText);
  } catch (error) {
    console.error('Gemini Proxy Error:', error);
    removeLoader();
    const errorMessage = `ðŸš¨ Could not connect to the AI service. Error: ${error.message}`;
    appendMessage('ai', errorMessage, true);
    speakText(cleanText(errorMessage));
  } finally {
    sendChatButton.disabled = false;
  }
}
    // --- User Actions ---
    function typeQuery() {
        const query = chatInput.value.trim();
        
        if (!query) return;

        // ðŸ”¥ NEW LOGIC: Check for location-sharing keyword and trigger getUserLocation ðŸ”¥
        const lowerQuery = query.toLowerCase();
        if (lowerQuery.includes('share my location') || lowerQuery.includes('get my location') || lowerQuery.includes('update location')) {
            // Since this is a user action, append the user's message first
            appendMessage('user', query);
            
            // Clear the input and trigger the location request instead of the AI
            chatInput.value = ''; 
            getUserLocation();
            return; 
        }
        
        if (query) {
            generateAiResponse(query);
        }
    }

    function handleKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevents a new line in the textarea
            typeQuery();
        }
        // Optional: Auto-resize textarea
        chatInput.style.height = 'auto';
        chatInput.style.height = (chatInput.scrollHeight) + 'px';
    }

    function summarizeChat() {
    stopSpeaking(); // Stop current speech
    
    const history = getChatHistory();
    if (history.length === 0) {
        appendMessage('ai', "There is no conversation history to summarize.", true);
        return;
    }

    const summaryPrompt = "Please generate a concise, bullet-point summary of the key topics, concepts, and conclusions from the following conversation history. Respond in a professional, educational tone.";
    
    // Add a temporary loader message
    const loaderMsgDiv = document.createElement('div');
    loaderMsgDiv.className = 'chat-message ai';
    loaderMsgDiv.id = 'summaryLoader';
    loaderMsgDiv.innerHTML = '<strong>Ai (Summary):</strong> <div class="loader-small"></div> Generating summary...';
    chatLog.appendChild(loaderMsgDiv);
    chatLog.scrollTop = chatLog.scrollHeight;
    
    // Prepare the conversation payload for the summary request
    const conversationContent = history.map(item => `${item.role.toUpperCase()}: ${item.text}`).join('\n');
    const summaryRequestContent = summaryPrompt + "\n\n--- Conversation History ---\n" + conversationContent;
    
    const summaryContents = [
        { role: "user", parts: [{ text: summaryRequestContent }] }
    ];

    // Send a dedicated API call for the summary
    fetch(proxyUrl, { 
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken') 
        },
        body: JSON.stringify({
            contents: summaryContents,
            config: { 
                temperature: 0.2,
                maxOutputTokens: 1024
            }
        })
    })
    .then(response => {
        if (!response.ok) {
            return response.text().then(text => {
                try {
                    const err = JSON.parse(text);
                    throw new Error(err.error?.message || `Status ${response.status}: Unknown API Error`);
                } catch (e) {
                    throw new Error(`Non-JSON response (Status ${response.status}). Check server/proxy connection.`);
                }
            });
        }
        return response.json();
    })
    .then(data => {
        // âœ… FIX: use simplified proxy response
        const displayText = data.text || "Could not generate summary.";
        
        const loader = document.getElementById('summaryLoader');
        if (loader) { loader.remove(); }
        
        const aiMsgDiv = document.createElement('div');
        aiMsgDiv.className = "chat-message ai";
        
        const contentSpan = document.createElement('span');
        aiMsgDiv.appendChild(contentSpan);
        chatLog.appendChild(aiMsgDiv);
        
        let i = 0;
        function typeSummary() {
            if (i < displayText.length) {
                contentSpan.textContent += displayText.charAt(i);
                i++;
                setTimeout(typeSummary, 10);
            } else {
                saveChatHistory();
                const speakableText = cleanText(displayText);
                speakText(speakableText);
            }
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        typeSummary();
    })
    .catch(error => {
        const loader = document.getElementById('summaryLoader');
        if (loader) { loader.remove(); }
        const errorMsgDiv = document.createElement('div');
        errorMsgDiv.className = "chat-message error";
        const summaryErrorText = "Could not generate summary due to a connection error: " + error.message;
        errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">ðŸš¨</span> ${cleanText(summaryErrorText)}`;
        chatLog.appendChild(errorMsgDiv);
        saveChatHistory();
        speakText("I encountered an error while generating the summary.");
    });
}
            
    function exportChat() {
        const history = getChatHistory();
        if (history.length === 0) {
            alert("No chat history to export!");
            return;
        }

        let exportText = `Praise AI Chat Export for ${username}\nDate: ${new Date().toLocaleString()}\n\n`;
        history.forEach(item => {
            exportText += `${item.role.toUpperCase()}: ${item.text}\n\n`;
        });

        const blob = new Blob([exportText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `learnflow_chat_${username}_${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function clearChat() {
        if (confirm("Are you sure you want to clear the entire chat history? This action cannot be undone.")) {
            localStorage.removeItem(chatHistoryKey);
            // Optionally, also clear the response count if the user is starting over fresh
            // localStorage.removeItem(responseCountKey);
            // responseCount = 0;
            
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Praise AI:</strong>
                    <span class="text-gray-400">
                        Hello! I'm Praise AI, your modern learning partner. Ask me anythingâ€”from local history to global trendsâ€”and let's make learning fun!
                    </span>
                </div>
            `;
            stopSpeaking();
            speakText("Chat history cleared. How can I help you start your learning journey today?");
            chatLog.scrollTop = chatLog.scrollHeight;
        }
    }

    // ## Local Storage Management ##

    function saveChatHistory() {
        const messages = [];
        // Only consider actual messages, not loaders or the initial welcome message from the template
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            const textContent = msgDiv.querySelector('span') ? msgDiv.querySelector('span').textContent.trim() : msgDiv.textContent.replace(role === 'user' ? 'You:' : 'Ai:', '').trim();
            
            if (textContent) {
                 messages.push({ role, text: textContent });
            }
        });

        // The save logic is slightly complex due to the typewriter effect. 
        // We will simplify by only saving the messages that are fully typed or user-sent messages.
        // For AI messages with the span, we'll use the span's content.

        // Re-implementing a safer save logic:
        const finalMessages = [];
        chatLog.querySelectorAll('.chat-message').forEach(msgDiv => {
            const role = msgDiv.classList.contains('user') ? 'user' : 'ai';
            let text = '';

            if (role === 'user') {
                // User messages are simple text
                // Use the textContent of the messageDiv after the strong tag for maximum safety
                const textNodes = Array.from(msgDiv.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
                text = textNodes.map(node => node.textContent.trim()).join(' ').trim();
            } else {
                // AI messages may have strong (role) and span (content)
                const contentSpan = msgDiv.querySelector('span');
                if (contentSpan) {
                     text = contentSpan.textContent.trim();
                } else {
                    // Fallback for AI messages without the span structure (like initial message)
                    text = msgDiv.textContent.replace('Ai:', '').trim();
                }
            }
            
            // Only save non-empty content (excluding the initial welcome text if it's still being typed)
            if (text) {
                 finalMessages.push({ role, text });
            }
        });

        localStorage.setItem(chatHistoryKey, JSON.stringify(finalMessages));
    }

    function getChatHistory() {
        const storedHistory = localStorage.getItem(chatHistoryKey);
        return storedHistory ? JSON.parse(storedHistory) : [];
    }

    function loadChatHistory() {
        const history = getChatHistory();
        chatLog.innerHTML = ''; // Clear the initial message template
        
        if (history.length === 0) {
            // Restore initial welcome message if history is empty
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Praise AI:</strong>
                    <span class="text-gray-400">
                        Hello! I'm Praise AI, your modern learning partner. Ask me anythingâ€”from local history to global trendsâ€”and let's make learning fun!
                    </span>
                </div>
            `;
            return;
        }

        history.forEach(item => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${item.role}`;
            
            // Render text content safely for both user and AI
            messageDiv.innerHTML = `<strong>${item.role === 'user' ? 'You' : 'Ai'}:</strong> `;
            const textNode = document.createTextNode(item.text);
            messageDiv.appendChild(textNode);
            
            chatLog.appendChild(messageDiv);
        });

        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Initialize
    window.onload = () => {
        loadChatHistory();
        initSpeechRecognition(); // Initialize recognition on page load
        
        // --- ADDED: Start the local time display ---
        updateAccurateLocalTime(); 
    };
</script>
{% endblock %}