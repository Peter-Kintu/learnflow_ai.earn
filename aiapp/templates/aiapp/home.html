{% extends "base.html" %}

{% block title %}Home - LearnFlow AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 90%; 
        margin: 2rem auto;
        background-color: #1f2937;
        border-radius: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 3rem;
        font-weight: 800;
        color: #ffffff;
        letter-spacing: -0.05em;
        line-height: 1.1;
    }

    .chat-header p {
        font-size: 1.125rem;
        color: #9ca3af;
        margin-top: 0.5rem;
        max-width: 32rem;
        margin-left: auto;
        margin-right: auto;
    }

    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; /* Stacks on all screens now */
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh; /* Base height for small screens */
    }

    /* Message styling (same) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    .chat-message.user { justify-content: flex-end; align-self: flex-end; background-color: #4338ca; color: #e0e7ff; }
    .chat-message.ai { justify-content: flex-start; align-self: flex-start; background-color: #2d3748; color: #e5e7eb; }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }

    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* MODIFIED: Integrated Input Container - Tighter vertical padding */
    .integrated-input-container {
        display: flex;
        align-items: center; 
        width: 100%;
        background-color: #0a0e16; 
        border-radius: 1rem; 
        border: 1px solid #4b5563;
        padding: 0.5rem 0.5rem; /* Reduced vertical padding for more space for input field */
        transition: border-color 0.3s, box-shadow 0.3s; 
    }
    
    /* NEW: Add a visual focus state to the container */
    .integrated-input-container:focus-within {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #4f46e5;
    }

    /* MODIFIED: #chatInput - Still no padding, maximizes space */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0; 
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; 
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; 
        min-height: 1.5rem; 
        max-height: 10rem; 
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; 
    }
    
    #chatInput:focus {
        outline: none; 
        box-shadow: none;
    }

    /* ðŸ”¥ MODIFIED: ICON BUTTON Base Styling - Reduced size for more input space ðŸ”¥ */
    .action-icon-button {
        flex-shrink: 0; 
        width: 2.5rem; /* Reduced from 3rem */
        height: 2.5rem; /* Reduced from 3rem */
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.2rem; /* Reduced icon size slightly */
        border-radius: 50%; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.25rem; /* Reduced from 0.5rem */
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* MODIFIED Send Button */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.25rem; /* Reduced from 0.5rem */
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* ðŸ”¥ MODIFIED: Responsive adjustments for large screens (md: 768px and up) ðŸ”¥ */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 80%; }
        /* REMOVED two-column layout: */
        /* .chat-area { flex-direction: row; min-height: 80vh; } */
        
        #chatLog { 
            width: auto; /* Full width */
            min-height: 60vh; 
            max-height: 60vh; /* Constrain log height */
            border-radius: 0; /* Reset */
            padding: 1.5rem; 
        }
        
        /* Input area now spans full width at the bottom: */
        .chat-input-area { 
            width: auto; 
            border-top: 1px solid #374151; /* Restore border */
            border-left: none; /* Remove side border */
            border-radius: 0 0 1.5rem 1.5rem; /* Rounded bottom corners */
            flex-direction: column; 
            justify-content: flex-start; 
        }

        /* Adjusted button group layout for larger screens: */
        .button-group { 
            flex-direction: row; /* Buttons are side-by-side */
            gap: 1rem; 
        }
        .action-button { 
            flex: 1; /* Equal width */
            max-width: 25%; 
        }
        .action-button.stop-speak { flex: 1; max-width: 25%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white tracking-tight">
            Welcome, {{ user.username }} <span class="wave-emoji inline-block">ðŸ‘‹</span>
        </h1>
        <p class="text-base sm:text-lg text-gray-400 font-light">
            Youâ€™ve joined LearnFlow AI, your powerful educational partner. 
        </p>
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Ai:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! 
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask LearnFlow AI
            </h2>
            {# MODIFIED: Buttons are now smaller, input area is wider #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                <button onclick="typeQuery()" class="action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">ðŸ”‡</span> Stop Speaking
                </button>
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput');
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton');
    const responseLimit = 10;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;

    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;

    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;


    // --- Core Chat Functions ---

    /**
     * Handles typing into the input field and sending the query.
     */
    function handleKeydown(event) {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault(); // Prevent newline
            typeQuery();
        }
    }

    /**
     * Appends a message to the chat log.
     * @param {string} role - 'user' or 'ai'
     * @param {string} text - The message content.
     */
    function appendMessage(role, text) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${role}`;
        
        // Sanitize the text for display, replace newline with <br> for pre-wrap
        const formattedText = text.replace(/\n/g, '<br>');

        messageDiv.innerHTML = `<strong>${role === 'user' ? 'You' : 'Ai'}:</strong> ${formattedText}`;
        chatLog.appendChild(messageDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        
        // Save history only for non-streaming messages or at the end of streaming
        if (role !== 'ai') {
            saveChatHistory();
        }
    }

    /**
     * Creates and appends a placeholder for AI's response while loading.
     */
    function showLoading() {
        // Disable input and buttons
        chatInput.disabled = true;
        sendChatButton.disabled = true;
        recordButton.disabled = true;
        
        // Add loader message
        const loaderDiv = document.createElement('div');
        loaderDiv.className = "chat-message ai";
        loaderDiv.id = "aiLoader";
        loaderDiv.innerHTML = '<strong>Ai:</strong> <div class="loader"></div>';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    /**
     * Removes the loading placeholder and re-enables controls.
     */
    function hideLoading() {
        const loader = document.getElementById('aiLoader');
        if (loader) {
            loader.remove();
        }
        chatInput.disabled = false;
        sendChatButton.disabled = false;
        recordButton.disabled = false;
        chatInput.focus();
    }
    
    /**
     * A utility function to ensure text is HTML-safe and suitable for pre-wrap.
     * @param {string} text - The text to clean.
     */
    function cleanText(text) {
        if (!text) return '';
        // 1. Basic HTML sanitization (replace <, > with entities)
        let cleaned = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // 2. Remove markdown artifacts that TTS/plain text doesn't need
        cleaned = cleaned.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Bold
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Italics
        cleaned = cleaned.replace(/###?\s/g, ''); // Headers
        cleaned = cleaned.replace(/- /g, ''); // List markers
        // 3. Remove newlines for a cleaner, continuous spoken stream
        // For spoken text, a newline is just a pause, so we replace it with a space.
        // For display, the original string with \n is better when used with pre-wrap.
        // Since this function is mostly used for *spoken* text, we keep the space.
        cleaned = cleaned.replace(/\n/g, ' '); 
        
        return cleaned;
    }

    /**
     * Core function to send query to the AI API (Flask backend).
     * @param {string} query - The user's input.
     * @param {string} source - 'text' or 'voice'.
     */
    async function sendQuery(query, source) {
        if (!query.trim()) return;

        // 1. Show user message and loading state
        appendMessage('user', query);
        chatInput.value = ''; // Clear input field
        showLoading();

        // 2. Fetch API key from the element
        const apiKeyElement = document.getElementById('gemini-api-key-home');
        if (!apiKeyElement) {
             hideLoading();
             appendMessage('ai', 'Error: Gemini API Key element not found.');
             return;
        }
        const apiKey = apiKeyElement.getAttribute('data-key');
        if (!apiKey) {
             hideLoading();
             appendMessage('ai', 'Error: Gemini API Key not configured. Please set the environment variable.');
             return;
        }

        // 3. Increment response count (for limit)
        responseCount++;
        localStorage.setItem(responseCountKey, responseCount);

        // 4. Enforce message limit
        if (responseCount > responseLimit) {
            hideLoading();
            const limitMsg = `You have reached your limit of ${responseLimit} responses for this session. Please refresh the page or clear chat to continue.`;
            appendMessage('ai', limitMsg);
            speakText(limitMsg);
            return;
        }
        
        // 5. Get current chat history for context
        const history = getChatHistory();
        const chatLogMessages = history.map(msg => ({
            role: msg.role === 'user' ? 'user' : 'model', // Map 'ai' to 'model' for the API
            text: msg.text
        }));

        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey // Send API key in header
                },
                body: JSON.stringify({
                    prompt: query,
                    history: chatLogMessages,
                    language: window.navigator.language || 'en-US' // Pass user language
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server responded with status: ${response.status}`);
            }

            const data = await response.json();
            const aiResponseText = data.response;

            // 6. Remove loader before typing effect
            hideLoading();
            
            // 7. Start the typing effect
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            
            const aiStrong = document.createElement('strong');
            aiStrong.textContent = "Ai:";
            aiMsgDiv.appendChild(aiStrong);

            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            chatLog.appendChild(aiMsgDiv);
            
            let i = 0;
            function typeResponse() {
                if (i < aiResponseText.length) {
                    // Use substring to ensure full characters are added
                    contentSpan.textContent += aiResponseText.charAt(i);
                    i++;
                    setTimeout(typeResponse, 10); // Adjust typing speed (ms)
                } else {
                    // Typing is complete
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(aiResponseText);
                    speakText(speakableText); 
                }
                // Keep the chat log scrolled to the bottom
                chatLog.scrollTop = chatLog.scrollHeight;
            }

            typeResponse();

        } catch (error) {
            console.error("Chat API Error:", error);
            hideLoading();
            const errorText = `Could not connect to the AI service. Error: ${error.message}`;
            appendMessage('ai', `ðŸš¨ ${errorText}`);
            speakText("I encountered an error while processing your request.");
        }
    }


    /**
     * Initiates the chat interaction from the text input field.
     */
    function typeQuery() {
        const query = chatInput.value.trim();
        if (query) {
            sendQuery(query, 'text');
        }
    }


    // --- Speech Recognition (STT) Functions ---

    /**
     * Initializes the Speech Recognition object.
     */
    function initSpeechRecognition() {
        if (!SpeechRecognition) {
            recordButton.disabled = true;
            recordButton.title = "Speech recognition not supported in this browser.";
            console.error("Speech Recognition not supported.");
            return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = false; // Capture a single utterance
        recognition.lang = window.navigator.language || 'en-US'; // Use user's browser language

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            recordButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 14H11V8h2v8z"/></svg>';
            recordButton.title = "Stop Recording / Analyzing...";
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            chatInput.value = transcript;
            recordButton.classList.remove('recording');
            recordButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/></svg>';
            recordButton.title = "Start Recording";

            // Automatically send the query after successful transcription
            if (transcript) {
                sendQuery(transcript, 'voice');
            }
        };

        recognition.onend = () => {
            isRecording = false;
            recordButton.classList.remove('recording');
            recordButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/></svg>';
            recordButton.title = "Start Recording";
        };

        recognition.onerror = (event) => {
            isRecording = false;
            recordButton.classList.remove('recording');
            recordButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/></svg>';
            recordButton.title = "Start Recording";
            console.error('Speech recognition error:', event.error);
        };
    }

    /**
     * Toggles the recording state.
     */
    function toggleRecording() {
        if (!recognition) {
            // Should not happen if check in initSpeechRecognition worked
            alert("Speech recognition is not supported in your browser.");
            return;
        }

        if (isRecording) {
            recognition.stop();
        } else {
            // Clear input first
            chatInput.value = '';
            // Stop any ongoing speech
            stopSpeaking();
            recognition.start();
        }
    }


    // --- Speech Synthesis (TTS) Functions ---

    /**
     * Stops the currently speaking utterance.
     */
    function stopSpeaking() {
        if (isSpeaking) {
            window.speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    /**
     * Speaks the given text using the Web Speech API.
     * @param {string} text - The text to speak.
     */
    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported.");
            return;
        }

        stopSpeaking(); // Stop any previous utterance

        // 1. Get a voice (prefer English/African voices if available)
        if (voices.length === 0) {
            voices = window.speechSynthesis.getVoices();
        }
        
        // Prioritize a few preferred languages, fallback to first available
        let selectedVoice = voices.find(voice => 
            voice.lang.startsWith('en-US') && voice.name.includes('Google')
        ) || voices.find(voice => 
            voice.lang.startsWith('en-GB') && voice.name.includes('Google')
        ) || voices.find(voice => 
            voice.lang.startsWith('en')
        ) || voices[0];
        
        if (!selectedVoice) {
            console.warn("No compatible voice found.");
            return;
        }

        // 2. Create the utterance
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.voice = selectedVoice;
        utterance.pitch = 1.0;
        utterance.rate = 1.0; // Normal speed

        // 3. Set event handlers
        utterance.onstart = () => {
            isSpeaking = true;
            stopSpeakingButton.style.display = 'inline-block';
        };

        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        };

        utterance.onerror = (event) => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
            console.error('SpeechSynthesisUtterance.onerror', event);
        };

        // 4. Speak
        window.speechSynthesis.speak(utterance);
    }


    // --- Utility Functions ---

    /**
     * Summarizes the current chat conversation using an API call.
     */
    async function summarizeChat() {
        stopSpeaking();
        const history = getChatHistory();

        if (history.length === 0) {
            appendMessage('ai', 'Nothing to summarize yet. Start a conversation!');
            speakText("Nothing to summarize yet. Start a conversation!");
            return;
        }

        const chatToSummarize = history.map(msg => `${msg.role}: ${msg.text}`).join('\n');
        
        // 1. Show loading state for summary
        const loaderDiv = document.createElement('div');
        loaderDiv.className = "chat-message ai";
        loaderDiv.id = "summaryLoader";
        loaderDiv.innerHTML = '<strong>Ai (Summary):</strong> <div class="loader"></div>';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        
        // 2. Fetch API key
        const apiKeyElement = document.getElementById('gemini-api-key-home');
        const apiKey = apiKeyElement ? apiKeyElement.getAttribute('data-key') : null;
        
        if (!apiKey) {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">ðŸš¨</span> Gemini API Key not configured.`;
             chatLog.appendChild(errorMsgDiv);
             return;
        }

        try {
            const response = await fetch('/api/summarize', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKey // Send API key in header
                },
                body: JSON.stringify({
                    chat_history: chatToSummarize,
                    language: window.navigator.language || 'en-US'
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server responded with status: ${response.status}`);
            }

            const data = await response.json();
            const displayText = data.summary; // Use the raw summary for typing
            
            // 3. Replace loader with typing effect
            const loader = document.getElementById('summaryLoader');
            if (loader) { loader.remove(); }

            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            chatLog.appendChild(aiMsgDiv);
            
            const aiStrong = document.createElement('strong');
            aiStrong.textContent = "Ai (Summary):";
            aiMsgDiv.appendChild(aiStrong);

            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            
            let i = 0;
            function typeSummary() {
                if (i < displayText.length) { // Use uncleaned text for display
                    contentSpan.textContent += displayText.charAt(i); 
                    i++;
                    setTimeout(typeSummary, 10);
                } else {
                    saveChatHistory();
                    // ðŸ”¥ FIX: Clean the text for speaking ONLY after typing is complete ðŸ”¥
                    const speakableText = cleanText(displayText);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeSummary();
            
        } catch (error) {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             const summaryErrorText = "Could not generate summary due to a connection error.";
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">ðŸš¨</span> ${cleanText(summaryErrorText)}`;
             chatLog.appendChild(errorMsgDiv);
             saveChatHistory();
             speakText("I encountered an error while generating the summary.");
        }
    }


    /**
     * Clears the chat history from the screen and local storage.
     */
    function clearChat() {
        if (confirm("Are you sure you want to clear the entire chat history? This action cannot be undone.")) {
            localStorage.removeItem(chatHistoryKey);
            localStorage.setItem(responseCountKey, 0); // Reset limit
            responseCount = 0;
            chatLog.innerHTML = `
                <div class="chat-message ai">
                    <strong>Ai:</strong>
                    <span class="text-gray-400">
                        Chat history cleared. How can I help you start your learning journey today?
                    </span>
                </div>
            `;
            stopSpeaking();
            chatInput.focus();
        }
    }

    /**
     * Exports the current chat history to a text file.
     */
    function exportChat() {
        const history = getChatHistory();
        if (history.length === 0) {
            alert("No chat history to export.");
            return;
        }

        let exportText = `LearnFlow AI Chat Export - User: ${username}\nDate: ${new Date().toLocaleString()}\n\n`;

        history.forEach(item => {
            exportText += `[${item.role.toUpperCase()}]\n${item.text}\n\n`;
        });

        const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `LearnFlow_Chat_${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }


    // --- History Management ---

    /**
     * Saves the current chat log to local storage.
     */
    function saveChatHistory() {
        const messages = chatLog.querySelectorAll('.chat-message');
        const finalMessages = [];

        messages.forEach(msg => {
            // Skip the initial welcome message template if it's the only one
            if (msg.id === 'initial-welcome' && messages.length > 1) {
                return;
            }
            
            // Get role and text
            const roleMatch = msg.className.match(/chat-message (user|ai|error)/);
            if (!roleMatch) return;
            const role = roleMatch[1];
            
            // Extract the text content from the inner span/content area
            // We use .innerText and then some light cleaning to capture the actual content
            let textElement = msg.querySelector('span') || msg;
            let text = textElement.innerText || msg.textContent; 

            // Clean up role prefix if it exists in the text (e.g., from an error message's strong tag)
            text = text.replace(/^(Ai|You|Ai \(Summary\)): /, '').trim();
            // Replace <br> back to \n for storage
            const innerHTML = msg.querySelector('span') ? msg.querySelector('span').innerHTML : '';
            text = innerHTML.replace(/<br>/g, '\n').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').trim() || text.trim();


            finalMessages.push({
                role: role,
                text: text
            });
        });

        localStorage.setItem(chatHistoryKey, JSON.stringify(finalMessages));
    }

    function getChatHistory() {
        const storedHistory = localStorage.getItem(chatHistoryKey);
        return storedHistory ? JSON.parse(storedHistory) : [];
    }

    function loadChatHistory() {
        const history = getChatHistory();
        chatLog.innerHTML = ''; // Clear the initial message template
        
        if (history.length === 0) {
            // Restore initial welcome message if history is empty
            chatLog.innerHTML = `
                <div class="chat-message ai" id="initial-welcome">
                    <strong>Ai:</strong>
                    <span class="text-gray-400">
                        Hello, {{ user.username }}! How can I help you start your learning journey today?
                    </span>
                </div>
            `;
            return;
        }

        history.forEach(item => {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${item.role}`;
            
            // Replace stored \n with <br> for proper display
            const formattedText = item.text.replace(/\n/g, '<br>');
            
            // Handle specific roles for display in the log
            let displayRole = item.role === 'user' ? 'You' : (item.role === 'error' ? 'Ai (Error)' : 'Ai');

            messageDiv.innerHTML = `<strong>${displayRole}:</strong> <span class="text-gray-400">${formattedText}</span>`;
            chatLog.appendChild(messageDiv);
        });

        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Initialize
    window.onload = () => {
        // Must fetch voices before use
        if ('speechSynthesis' in window) {
            voices = window.speechSynthesis.getVoices();
            window.speechSynthesis.onvoiceschanged = () => {
                voices = window.speechSynthesis.getVoices();
            };
        }
        
        loadChatHistory();
        initSpeechRecognition(); // Initialize recognition on page load
    };
</script>
{% endblock %}