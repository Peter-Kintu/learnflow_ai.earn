{% extends "base.html" %}

{% block title %}Home - LearnFlow AI{% endblock %}

{% block content %}
<style>
    /* Base styling for a clean dark theme */
    body {
        background: linear-gradient(135deg, #101725, #0a0e16);
        font-family: 'Inter', sans-serif;
        color: #e5e7eb;
    }

    /* General container and card styling - Wider on all screens */
    .chat-container-card {
        max-width: 90%; 
        margin: 2rem auto;
        background-color: #1f2937;
        border-radius: 1.5rem;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        border: 1px solid #374151;
        overflow: hidden;
        transition: all 0.5s ease-in-out;
    }

    /* Header styling */
    .chat-header {
        background: linear-gradient(135deg, #2d3748, #1f2937);
        padding: 2.5rem 1.5rem;
        border-bottom: 1px solid #374151;
        text-align: center;
    }

    .chat-header h1 {
        font-size: 3rem;
        font-weight: 800;
        color: #ffffff;
        letter-spacing: -0.05em;
        line-height: 1.1;
    }

    .chat-header p {
        font-size: 1.125rem;
        color: #9ca3af;
        margin-top: 0.5rem;
        max-width: 32rem;
        margin-left: auto;
        margin-right: auto;
    }

    /* Main chat area layout */
    .chat-area {
        display: flex;
        flex-direction: column; /* Stacks on all screens now */
        padding: 0; 
        gap: 0;
    }

    /* Chat log container - No boundaries */
    #chatLog {
        flex-grow: 1;
        overflow-y: auto;
        padding: 1.5rem; 
        background-color: transparent; 
        border: none;
        border-radius: 0;
        transition: all 0.3s ease-in-out;
        min-height: 50vh; 
        max-height: 70vh; /* Base height for small screens */
    }

    /* Message styling (same) */
    .chat-message {
        display: flex;
        align-items: flex-start;
        margin-bottom: 1rem;
        padding: 0.75rem 1rem;
        border-radius: 1rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        max-width: 95%; 
        line-height: 1.5;
        font-size: 1rem;
    }
    .chat-message strong { font-weight: 700; margin-right: 0.5rem; min-width: fit-content; }
    .chat-message.user { justify-content: flex-end; align-self: flex-end; background-color: #4338ca; color: #e0e7ff; }
    .chat-message.ai { justify-content: flex-start; align-self: flex-start; background-color: #2d3748; color: #e5e7eb; }
    .chat-message.error { background-color: #b91c1c; color: #ffffff; border: 1px solid #dc2626; }

    /* Input and button area */
    .chat-input-area {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 1.5rem;
        border-top: 1px solid #374151;
        background-color: #1f2937;
    }
    
    /* MODIFIED: Integrated Input Container - Tighter vertical padding */
    .integrated-input-container {
        display: flex;
        align-items: center; 
        width: 100%;
        background-color: #0a0e16; 
        border-radius: 1rem; 
        border: 1px solid #4b5563;
        padding: 0.5rem 0.5rem; /* Reduced vertical padding for more space for input field */
        transition: border-color 0.3s, box-shadow 0.3s; 
    }
    
    /* NEW: Add a visual focus state to the container */
    .integrated-input-container:focus-within {
        border-color: #4f46e5;
        box-shadow: 0 0 0 2px #4f46e5;
    }

    /* MODIFIED: #chatInput - Still no padding, maximizes space */
    #chatInput {
        flex-grow: 1; 
        width: 100%;
        padding: 0; 
        border-radius: 0;
        border: none;
        background-color: transparent; 
        color: #e5e7eb;
        font-size: 1.1rem; 
        box-shadow: none; 
        display: block;
        margin: 0;
        resize: none; 
        overflow: auto; 
        min-height: 1.5rem; 
        max-height: 10rem; 
    }

    #chatInput::placeholder {
        color: #9ca3af;
        text-align: left; 
    }
    
    #chatInput:focus {
        outline: none; 
        box-shadow: none;
    }

    /* 🔥 MODIFIED: ICON BUTTON Base Styling - Reduced size for more input space 🔥 */
    .action-icon-button {
        flex-shrink: 0; 
        width: 2.5rem; /* Reduced from 3rem */
        height: 2.5rem; /* Reduced from 3rem */
        border: none;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.1s;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0; 
        font-size: 1.2rem; /* Reduced icon size slightly */
        border-radius: 50%; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); 
    }

    /* Updated Microphone/Record Button */
    #recordButton {
        background-color: #ef4444; 
        color: white;
        margin-right: 0.25rem; /* Reduced from 0.5rem */
    }
    
    #recordButton:hover {
        background-color: #dc2626;
        transform: scale(1.05);
    }

    #recordButton.recording {
        background-color: #10b981; 
        animation: pulse 1.5s infinite;
    }
    
    #recordButton:disabled {
        background-color: #4b5563;
        cursor: not-allowed;
        animation: none;
        transform: none;
    }

    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        50% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
    }
    
    /* MODIFIED Send Button */
    #sendChatButton {
        background-color: #4f46e5; 
        color: #fff; 
        margin-left: 0.25rem; /* Reduced from 0.5rem */
    }

    #sendChatButton:hover { 
        background-color: #4338ca; 
        transform: scale(1.05); 
    } 
    
    /* Hide the old voice status div as it's not needed in this layout */
    #voiceStatus {
        display: none;
    }
    
    /* Button Group Styling (Unchanged) */
    .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        justify-content: center;
    }
    
    .action-button {
        flex: 1 1 150px; 
        padding: 0.75rem 1.5rem;
        border-radius: 1.5rem;
        font-weight: 600;
        text-align: center;
        transition: all 0.3s ease-in-out;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .action-button.stop-speak { 
        background-color: #f59e0b; 
        color: #1f2937; 
        display: none; 
        order: -1; 
    }
    .action-button.stop-speak:hover { background-color: #d97706; transform: translateY(-2px); }
    .action-button.summarize { background-color: #10b981; color: #fff; }
    .action-button.summarize:hover { background-color: #059669; transform: translateY(-2px); }
    .action-button.export { background-color: #3b82f6; color: #fff; }
    .action-button.export:hover { background-color: #2563eb; transform: translateY(-2px); }
    .action-button.clear { background-color: #ef4444; color: #fff; }
    .action-button.clear:hover { background-color: #dc2626; transform: translateY(-2px); }
    
    /* 🔥 MODIFIED: Responsive adjustments for large screens (md: 768px and up) 🔥 */
    @media (min-width: 768px) {
        .chat-container-card { max-width: 80%; }
        /* REMOVED two-column layout: */
        /* .chat-area { flex-direction: row; min-height: 80vh; } */
        
        #chatLog { 
            width: auto; /* Full width */
            min-height: 60vh; 
            max-height: 60vh; /* Constrain log height */
            border-radius: 0; /* Reset */
            padding: 1.5rem; 
        }
        
        /* Input area now spans full width at the bottom: */
        .chat-input-area { 
            width: auto; 
            border-top: 1px solid #374151; /* Restore border */
            border-left: none; /* Remove side border */
            border-radius: 0 0 1.5rem 1.5rem; /* Rounded bottom corners */
            flex-direction: column; 
            justify-content: flex-start; 
        }

        /* Adjusted button group layout for larger screens: */
        .button-group { 
            flex-direction: row; /* Buttons are side-by-side */
            gap: 1rem; 
        }
        .action-button { 
            flex: 1; /* Equal width */
            max-width: 25%; 
        }
        .action-button.stop-speak { flex: 1; max-width: 25%; }
    }

    /* Loader styling (same) */
    .loader { width: 32px; height: 32px; border: 4px solid #4f46e5; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; margin: 1.5rem auto; }
    @keyframes spin { to { transform: rotate(360deg); } }
</style>

<div class="chat-container-card">
    <div class="chat-header">
        <h1 class="text-4xl sm:text-5xl font-extrabold text-white tracking-tight">
            Welcome, {{ user.username }} <span class="wave-emoji inline-block">👋</span>
        </h1>
        <p class="text-base sm:text-lg text-gray-400 font-light">
            You’ve joined LearnFlow AI, your powerful educational partner. 
        </p>
    </div>

    <div class="chat-area">
        <div id="chatLog" class="overflow-y-auto">
            <div class="chat-message ai">
                <strong>Ai:</strong>
                <span class="text-gray-400">
                    Hello, {{ user.username }}! 
                </span>
            </div>
        </div>

        <div class="chat-input-area">
            <h2 class="text-2xl font-semibold text-indigo-400 flex items-center gap-2">
                <svg class="w-7 h-7 text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 10a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.549A9.863 9.863 0 0112 4c4.97 0 9 3.582 9 8z" />
                </svg>
                Ask LearnFlow AI 
            </h2>
            
            {# MODIFIED: Buttons are now smaller, input area is wider #}
            <div class="integrated-input-container">
                <button id="recordButton" onclick="toggleRecording()" class="action-icon-button" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.9-3.4 7-7.3 7s-7.3-3.1-7.3-7H4c0 4.3 3.3 7.8 7.5 8.3v3.7h1v-3.7c4.2-.5 7.5-4 7.5-8.3h-2.7z"/>
                    </svg>
                </button>
                
                <textarea id="chatInput" placeholder="Type your question or tap the mic to speak..." onkeydown="handleKeydown(event)"></textarea>
                
                <button onclick="typeQuery()" class="action-icon-button" id="sendChatButton" title="Send Message">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.01 21L23 12 2.01 3v7l15 2-15 2v7z"/>
                    </svg>
                </button>
            </div>
            
            {# Old voiceStatus and old input wrapper removed. #}
            <div id="voiceStatus"></div>

            <div class="button-group">
                <button onclick="stopSpeaking()" class="action-button stop-speak" id="stopSpeakingButton">
                    <span class="text-xl">🔇</span> Stop Speaking
                </button>
                
                <button onclick="summarizeChat()" class="action-button summarize">Summarize Chat</button>
                <button onclick="exportChat()" class="action-button export">Export Chat</button>
                <button onclick="clearChat()" class="action-button clear">Clear Chat</button>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and Global Variables
    const chatLog = document.getElementById('chatLog');
    const stopSpeakingButton = document.getElementById('stopSpeakingButton');
    const recordButton = document.getElementById('recordButton');
    const voiceStatus = document.getElementById('voiceStatus');
    const chatInput = document.getElementById('chatInput'); 
    // NEW: Get the send button for potential status updates (though not strictly required)
    const sendChatButton = document.getElementById('sendChatButton'); 

    const responseLimit = 10;
    const username = "{{ user.username }}";
    const chatHistoryKey = `chatHistory-${username}`;
    const responseCountKey = `responseCount-${username}`;
    let responseCount = localStorage.getItem(responseCountKey) ? parseInt(localStorage.getItem(responseCountKey)) : 0;
    
    // --- Speech Synthesis Variables (TTS) ---
    let voices = [];
    let isSpeaking = false;
    
    // --- Speech Recognition Variables (STT) ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isRecording = false;
    
    // 🔥 NEW CONSTANT: Set the African Language Code for Speech Recognition (STT) 🔥
    // Swahili (Tanzania) is generally the most robust African language supported by Chrome/browser STT.
    // Try other codes like 'ha-NG' (Hausa) or 'zu-ZA' (Zulu) if you prefer.
    const africanLanguageCode = 'sw-TZ'; 

    // --- API Configuration ---
    // NOTE: Replace the placeholder with your actual Gemini API key.
    const apiKey = "AIzaSyBo-nakWm_HBUBStldTAKzcAdvB4OU46HU"; 
    const modelName = 'gemini-2.5-flash'; 
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
    
    // 🔥 NEW CONSTANT: System instruction to force the AI to understand African languages 🔥
    const systemInstruction = `You are LearnFlow AI, an educational partner. Your goal is to be highly proficient and helpful in answering questions in many languages. You must prioritize understanding and responding in African languages, including **Luganda**, Swahili, Hausa, Yoruba, Zulu, and others. Always respond in the language the user is using, maintaining context and educational quality.`;

    /**
     * Cleans the AI response text by removing markdown formatting and disruptive symbols 
     * before text-to-speech conversion.
     * @param {string} text The raw text from the API.
     * @returns {string} The cleaned text.
     */
    function cleanText(text) {
        let cleaned = text;
        
        // 1. Remove link/citation brackets and their content
        cleaned = cleaned.replace(/\[(.*?)\]/g, '$1'); // Keep content content inside brackets, remove brackets themselves (e.g. for [text](link))

        // 2. Remove common markdown bold/italic/strikethrough symbols (**, *, __, _, ~~).
        cleaned = cleaned.replace(/(\*\*|__)(.*?)\1/g, '$2'); // Removes ** and __ for bold/strong
        cleaned = cleaned.replace(/(\*|_)(.*?)\1/g, '$2'); // Removes * and _ for italics/emphasis
        cleaned = cleaned.replace(/~~(.*?)~~/g, '$1'); // Removes ~~ for strikethrough

        // 3. Remove list markers, headings, and specific disruptive punctuation (like " and lone *)
        cleaned = cleaned.replace(/^\s*[-*]+\s+/gm, ''); // Removes list markers: -, *, --, etc. at the start of a line
        cleaned = cleaned.replace(/#+\s*/g, ''); // Removes heading symbols (e.g., #, ##, ###)
        cleaned = cleaned.replace(/"/g, '');      // Remove all double quotes (user requested)
        cleaned = cleaned.replace(/---/g, ' ');   // Remove triple dashes (horizontal rule)
        cleaned = cleaned.replace(/--/g, ' ');    // Remove double dashes (en/em dashes)
        cleaned = cleaned.replace(/-/g, ' ');     // Remove remaining single hyphens (user requested, replace with space)

        // 4. Clean up excessive whitespace that might result from removals
        cleaned = cleaned.replace(/\s\s+/g, ' '); // Replace multiple spaces with a single space
        
        return cleaned.trim(); // Trim leading/trailing whitespace
    }


    // ## TTS Functions (MODIFIED: speakText) ##
    
    function populateVoices() {
        voices = speechSynthesis.getVoices();
    }
    
    populateVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = populateVoices;
    }

    function speakText(text) {
        if (!'speechSynthesis' in window) {
            console.warn("Speech Synthesis not supported in this browser.");
            return;
        }

        stopSpeaking(); 

        isSpeaking = true;
        stopSpeakingButton.style.display = 'block'; 

        // NOTE: The text passed to this function should already be cleaned
        // The cleaning happens in typeWriter/transcriptQuery/summarizeChat before this call
        const utterance = new SpeechSynthesisUtterance(text);
        
        // 🔥 MODIFIED: Change the voice tone (pitch) and rate (speed) 🔥
        utterance.pitch = 1.2; // Higher tone (e.g., 1.2)
        utterance.rate = 0.95; // Slightly slower speed (e.g., 0.95)

        // 🔥 MODIFIED: Enhanced Voice Selection for Multilingual/African Languages 🔥
        // This attempts to find voices that support African languages well and other languages
        const voicePreferences = [
            // Priority 1: African-related languages (may only be available on certain OS/browsers)
            { lang: 'en-ZA', name: 'South African' }, // Regional English accent
            { lang: 'zu', name: 'Zulu' }, 
            { lang: 'sw', name: 'Swahili' }, 
            { lang: 'ha', name: 'Hausa' }, 
            // Priority 2: High-quality, often multilingual/polyglot voices
            { lang: 'Google', name: 'Multi' }, 
            { lang: 'Microsoft', name: 'Multi' },
            // Priority 3: Other high-quality defaults
            { lang: 'Daniel', name: 'Daniel' }, 
            { lang: 'Samantha', name: 'Samantha' }, 
            { lang: 'Zira', name: 'Zira' }
        ];

        let selectedVoice = null;
        for (let pref of voicePreferences) {
            // Find a voice by name OR by language code match
            selectedVoice = voices.find(voice => 
                voice.name.includes(pref.name) || voice.lang.includes(pref.lang)
            );
            if (selectedVoice) break;
        }
        
        // Final fallback: any voice with an English language code
        if (!selectedVoice) {
            selectedVoice = voices.find(voice => voice.lang.includes('en'));
        }
        
        // If a voice is found, set it
        if (selectedVoice) {
            utterance.voice = selectedVoice;
        }
        
        utterance.onend = () => {
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none'; 
            if (!isRecording) {
                 // Removed voiceStatus update here since it's hidden, but keeping the logic intact
            }
        };
        
        utterance.onerror = (event) => {
            console.error('Speech synthesis error:', event);
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
             if (!isRecording) {
                 // Removed voiceStatus update here since it's hidden, but keeping the logic intact
            }
        };

        speechSynthesis.speak(utterance);
    }
    
    function stopSpeaking() {
        if ('speechSynthesis' in window && speechSynthesis.speaking) {
            speechSynthesis.cancel();
            isSpeaking = false;
            stopSpeakingButton.style.display = 'none';
        }
    }

    // ## STT Functions (MODIFIED: recognition.lang) ##

    function setupRecognition() {
        if (!SpeechRecognition) {
            // Updated status message for the new combined input
            chatInput.placeholder = "Voice input is not supported in this browser. Type your question here...";
            recordButton.disabled = true;
            return;
        }
        
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        // 🔥 MODIFIED: Set the language code to a supported African language 🔥
        recognition.lang = africanLanguageCode; 

        recognition.onstart = () => {
            isRecording = true;
            recordButton.classList.add('recording');
            chatInput.placeholder = "Listening... Speak clearly now."; // Use input placeholder for status
            stopSpeaking(); // Stop AI from talking when user starts speaking
        };

        // 🔥 MODIFIED: Put transcript into the input field instead of sending it directly 🔥
        recognition.onresult = (event) => {
            const last = event.results.length - 1;
            const transcript = event.results[last][0].transcript;
            console.log("Transcript:", transcript);
            chatInput.value = transcript; // <-- THIS IS THE KEY CHANGE
            chatInput.placeholder = "Transcript ready. Tap Send or Enter to submit.";
            // The user must now press 'Send' or 'Enter'
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            recordButton.classList.remove('recording');
            isRecording = false;
            if (event.error !== 'no-speech') {
                chatInput.placeholder = `Error: ${event.error}. Tap the mic to try again.`;
            } else {
                 chatInput.placeholder = "Didn't catch that. Tap the mic or type your question here...";
            }
        };
        
        recognition.onend = () => {
            if (isRecording) {
                 recordButton.classList.remove('recording');
                 // Only reset placeholder if the transcript wasn't successful or sent
                 if (chatInput.value === '' || chatInput.placeholder.includes("Listening")) { 
                     chatInput.placeholder = "Tap the mic or type your question here...";
                 }
                 isRecording = false;
            }
        };
    }
    
    // Initialize recognition on load
    setupRecognition();

    function toggleRecording() {
        if (isRecording) {
            recognition.stop();
        } else {
            try {
                recognition.start();
            } catch (e) {
                 if (e.name !== 'InvalidStateError') {
                     console.error("Recording error:", e);
                     chatInput.placeholder = "Error starting mic. Check console/permissions.";
                 }
            }
        }
    }
    
    // NEW: Function to handle text input submission (Now handles both typed and voice-transcribed input)
    function typeQuery() {
        const query = chatInput.value.trim();
        if (query) {
            transcriptQuery(query);
            chatInput.value = ''; // Clear the input after sending
            chatInput.placeholder = "Tap the mic or type your question here..."; // Reset placeholder
            // Reset textarea height after clearing (important for auto-growing textarea)
            chatInput.style.height = 'auto'; 
        } else {
            console.warn("Input field is empty.");
        }
    }

    // NEW: Function to handle 'Enter' key press on the input field
    function handleKeydown(event) {
        // If shift or ctrl is pressed, allow for a new line instead of sending
        if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey) {
            typeQuery();
            event.preventDefault(); 
        } else if (event.key === 'Enter' && (event.shiftKey || event.ctrlKey)) {
            // Allows Shift+Enter or Ctrl+Enter for a new line
            // The auto-growing textarea handles the height change
        }
    }
    
    // Function to handle auto-growing textarea
    function autoGrowTextarea() {
        chatInput.style.height = 'auto';
        chatInput.style.height = chatInput.scrollHeight + 'px';
    }

    // Attach listeners on load
    document.addEventListener('DOMContentLoaded', () => {
        chatInput.addEventListener('keydown', handleKeydown);
        chatInput.addEventListener('input', autoGrowTextarea); // Attach autogrow listener
        autoGrowTextarea(); // Set initial height
    });
    
    // OLD: Renamed sendChat to transcriptQuery for voice input workflow, now handles text input too (UNCHANGED logic)
    async function transcriptQuery(query) {
        if (!query.trim()) {
            // Removed voiceStatus update, using console.warn
            return;
        }

        stopSpeaking(); // Ensure AI stops speaking if user interrupts
        
        // Display user message
        const userMsgDiv = document.createElement('div');
        userMsgDiv.className = "chat-message user";
        // SECURITY FIX: Prevent HTML injection by appending the query as a text node,
        // which automatically escapes HTML characters.
        userMsgDiv.innerHTML = `<strong>You:</strong> `; 
        userMsgDiv.appendChild(document.createTextNode(query));
        chatLog.appendChild(userMsgDiv);
        chatLog.scrollTop = chatLog.scrollHeight;
        saveChatHistory();
        
        // Rate Limit Check
        if (responseCount >= responseLimit) {
            const upgradeMsg = "You've reached your free chat limit! Please upgrade for unlimited access.";
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai error"; 
            aiMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">🔒</span> ${upgradeMsg}`;
            chatLog.appendChild(aiMsgDiv);
            saveChatHistory();
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText(cleanText(upgradeMsg)); // Speak the CLEANED error message
            return;
        }

        const loaderDiv = document.createElement('div');
        loaderDiv.id = 'loader';
        loaderDiv.className = 'loader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;

        try {
            const conversationHistory = getConversationHistory();
            
            // 🔥 FINAL FIX: Inject the system instruction into the current user message's text
            // This avoids the "Invalid role: system" API error.
            const finalUserMessageText = `${systemInstruction}\n\n[USER INPUT]: ${query}`;

            const payload = {
                contents: [
                    // Note: If conversationHistory is empty, this starts with the user message, which is fine.
                    // If it is not empty, it contains alternating user/model turns.
                    ...conversationHistory, // Previous user/model turns
                    { role: 'user', parts: [{ text: finalUserMessageText }] } // Current turn with system instruction injected
                ]
            };

            const response = await fetch(apiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            
            const data = await response.json();
            
            const loader = document.getElementById('loader');
            if (loader) { loader.remove(); }
            
            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai"; 
            chatLog.appendChild(aiMsgDiv);
            
            let fullText = "No response received. Please check the console (F12) for API errors.";
            let isError = false;

            if (data?.candidates?.[0]?.content?.parts?.length) {
                fullText = data.candidates[0].content.parts.map(p => p.text).join("\n\n");
            } else if (data.error) {
                 fullText = `API Error: ${data.error.message || "An unknown API error occurred."}`;
                 isError = true;
            } else if (data.promptFeedback?.blockReason) {
                 fullText = `Response blocked. Reason: ${data.promptFeedback.blockReason}`;
                 isError = true;
            }

            // 🔥 FIX: Use the raw fullText for DISPLAY (no cleanText here) 🔥
            const displayText = fullText;

            if (isError) {
                const speakableText = cleanText(fullText); // Clean error text for speaking
                aiMsgDiv.classList.add('error');
                aiMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">🚫</span> ${speakableText}`;
                saveChatHistory();
                speakText("I encountered an error. " + speakableText); 
            } else {
                // Pass the ORIGINAL uncleaned text to typeWriter for display
                typeWriter(aiMsgDiv, displayText); 
                responseCount++;
            }
            
            chatLog.scrollTop = chatLog.scrollHeight;
            
        } catch (error) {
            console.error("Fetch/Network Error:", error);
            const loader = document.getElementById('loader');
            if (loader) { loader.remove(); }
            
            const errorMsgDiv = document.createElement('div');
            errorMsgDiv.className = "chat-message error"; 
            const errorText = "Network Error. Could not reach the server.";
            errorMsgDiv.innerHTML = `<strong>Ai:</strong> <span class="text-xl inline-block mr-2">🚨</span> ${cleanText(errorText)}`;
            saveChatHistory();
            chatLog.appendChild(errorMsgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText("I encountered a network error.");
        }
    }

    // ## Core Chat/API Functions (UNCHANGED) ##

    // Load chat history from localStorage on page load
    document.addEventListener('DOMContentLoaded', () => {
        const storedChat = localStorage.getItem(chatHistoryKey);
        stopSpeakingButton.style.display = 'none';

        if (storedChat) {
            chatLog.innerHTML = storedChat;
            // Existing logic to handle old class names... (omitted for brevity, assume it runs)
            
            // Re-check if the initial welcome message is missing and add it back
            if (!chatLog.innerHTML.includes("educational assistant powered by the Gemini Flash model")) {
                chatLog.innerHTML = `
                    <div class="chat-message ai">
                        <strong>Ai:</strong>
                        <span class="text-gray-400">
                            Hello, {{ user.username }}! 
                        </span>
                    </div>` + chatLog.innerHTML;
            } 
            
            chatLog.scrollTop = chatLog.scrollHeight;
        } else {
             // Add initial welcome message if no history exists
             chatLog.innerHTML = `
                 <div class="chat-message ai">
                     <strong>Ai:</strong> 
                 <span class="text-gray-400">
                     Hello, {{ user.username }}! 
                 </span>
                 </div>`;
        }
    });

    function saveChatHistory() {
        localStorage.setItem(chatHistoryKey, chatLog.innerHTML);
        localStorage.setItem(responseCountKey, responseCount);
    }

    // Typing animation function - **Now calls speakText on completion with CLEANED text**
    function typeWriter(element, text, speed = 10) {
        let i = 0;
        element.innerHTML = `<strong>Ai:</strong> `;
        const contentSpan = document.createElement('span');
        element.appendChild(contentSpan);

        function type() {
            if (i < text.length) {
                contentSpan.textContent += text.charAt(i); 
                i++;
                setTimeout(type, speed);
            } else {
                saveChatHistory();
                // 🔥 FIX: Clean the text for speaking ONLY after typing is complete 🔥
                const speakableText = cleanText(text);
                speakText(speakableText); 
            }
            chatLog.scrollTop = chatLog.scrollHeight;
        }
        type();
    }
    
    /**
     * Extracts conversation history, excluding errors and the system instruction,
     * in the format required for the Gemini API contents array.
     */
    function getConversationHistory() {
        const history = [];
        const children = Array.from(chatLog.children);

        for (const child of children) {
            const isUser = child.classList.contains('user');
            const isAI = child.classList.contains('ai');
            
            // Filter out system messages, loaders, and internal messages
            if (child.classList.contains('error') || child.id === 'loader' || child.id === 'summaryLoader' || child.innerText.includes("educational assistant powered by the Gemini Flash model")) {
                continue;
            }

            if (isUser) {
                // Extract only the text displayed to the user
                const text = child.textContent.replace('You:', '').trim(); 
                history.push({ role: 'user', parts: [{ text: text }] });
            } else if (isAI) {
                // Clean up all possible AI prefixes
                const text = child.textContent
                             .replace('Ai (Summary):', '')
                             .replace('Ai:', '')
                             .replace('Summary:', '')
                             .trim();
                             
                // Remove formatting from the content being sent back to the API for context
                const cleanedTextForAPI = cleanText(text);

                // Note: The role for AI responses in the history is 'model'
                if (cleanedTextForAPI) { history.push({ role: 'model', parts: [{ text: cleanedTextForAPI }] }); }
            }
        }
        return history;
    }

    // Function to clear the chat history and the chat log display
    function clearChat() {
        stopSpeaking(); 
        chatLog.innerHTML = '';
        localStorage.removeItem(chatHistoryKey);
        responseCount = 0;
        localStorage.setItem(responseCountKey, '0');
        // Re-add the welcome message
        chatLog.innerHTML = `
             <div class="chat-message ai">
                 <strong>Ai:</strong> 
                 <span class="text-gray-400">
                     Hello, {{ user.username }}! 
                 </span>
             </div>`;
    }

    function exportChat() {
        stopSpeaking(); 
        const plainText = chatLog.innerText;
        const blob = new Blob([plainText], { type: 'text/plain;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'LearnFlow_Chat_Transcript.txt'; 
        link.click();
    }
    
    // Summarize function - **Now uses text injection to avoid role: "system"**
    async function summarizeChat() {
        stopSpeaking(); 
        
        const conversationHistory = getConversationHistory();
        
        const historyForSummary = conversationHistory.filter(message => 
            !message.parts[0].text.includes("Please provide a concise, numbered summary of the previous conversation")
        );

        if (historyForSummary.length === 0) {
            const warningMsgDiv = document.createElement('div');
            const noSummaryText = "No conversation to summarize. Start chatting!";
            warningMsgDiv.className = "chat-message error";
            warningMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">⚠️</span> ${cleanText(noSummaryText)}`;
            chatLog.appendChild(warningMsgDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
            speakText(cleanText(noSummaryText)); 
            return;
        }

        const loaderDiv = document.createElement('div');
        loaderDiv.id = 'summaryLoader';
        loaderDiv.className = 'loader';
        chatLog.appendChild(loaderDiv);
        chatLog.scrollTop = chatLog.scrollHeight;

        const summaryPrompt = "Please provide a concise, numbered summary of the previous conversation. Focus on the main topics and conclusions. Address the user directly as 'you'.";

        // 🔥 FINAL FIX: Inject the system instruction into the summary prompt text
        const finalSummaryPrompt = `${systemInstruction}\n\n[SUMMARY REQUEST]: ${summaryPrompt}`;

        const payload = {
            contents: [
                ...historyForSummary, // The clean history
                { role: 'user', parts: [{ text: finalSummaryPrompt }] } // Summary request with system instruction injected
            ]
        };

        try {
            const response = await fetch(apiUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });

            const data = await response.json();

            const loader = document.getElementById('summaryLoader');
            if (loader) { loader.remove(); }

            const aiMsgDiv = document.createElement('div');
            aiMsgDiv.className = "chat-message ai";
            chatLog.appendChild(aiMsgDiv);

            let fullText = data.candidates?.[0]?.content?.parts?.[0]?.text || "No summary available. Check console for API errors.";
            
            // 🔥 FIX: Use the raw fullText for DISPLAY (no cleanText here) 🔥
            const displayText = fullText;

            aiMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> `;
            const contentSpan = document.createElement('span');
            aiMsgDiv.appendChild(contentSpan);
            
            let i = 0;
            function typeSummary() {
                if (i < displayText.length) { // Use uncleaned text for display
                    contentSpan.textContent += displayText.charAt(i); 
                    i++;
                    setTimeout(typeSummary, 10);
                } else {
                    saveChatHistory();
                    // 🔥 FIX: Clean the text for speaking ONLY after typing is complete 🔥
                    const speakableText = cleanText(displayText);
                    speakText(speakableText); 
                }
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            typeSummary();
            
        } catch (error) {
             const loader = document.getElementById('summaryLoader');
             if (loader) { loader.remove(); }
             const errorMsgDiv = document.createElement('div');
             errorMsgDiv.className = "chat-message error";
             const summaryErrorText = "Could not generate summary due to a connection error.";
             errorMsgDiv.innerHTML = `<strong>Ai (Summary):</strong> <span class="text-xl inline-block mr-2">🚨</span> ${cleanText(summaryErrorText)}`;
             chatLog.appendChild(errorMsgDiv);
             saveChatHistory();
             speakText("I encountered an error while generating the summary.");
        }
    }
</script>
{% endblock %}